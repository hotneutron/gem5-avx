// Copyright (c) 2009 The Regents of The University of Michigan
// Copyright (c) 2015 Advanced Micro Devices, Inc.
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met: redistributions of source code must retain the above copyright
// notice, this list of conditions and the following disclaimer;
// redistributions in binary form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution;
// neither the name of the copyright holders nor the names of its
// contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

def template AVXOpExecute {{
        Fault %(class_name)s::execute(ExecContext *xc,
                Trace::InstRecord *traceData) const
        {
            Fault fault = NoFault;

            %(op_decl)s;
            %(op_rd)s;

            %(code)s;

            //Write the resulting state to the execution context
            if(fault == NoFault)
            {
                %(op_wb)s;
            }
            return fault;
        }
}};

def template AVXOpRegDeclare {{
    class %(class_name)s : public %(base_class)s
    {
      public:
        %(class_name)s(ExtMachInst _machInst,
                const char * instMnem, uint64_t setFlags,
                InstRegIndex _src1, InstRegIndex _src2,
                InstRegIndex _src3, InstRegIndex _dest,
                uint8_t _srcSize, uint8_t _destSize, uint16_t _ext);

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

def template AVXOpImmDeclare {{

    class %(class_name)s : public %(base_class)s
    {
      public:
        %(class_name)s(ExtMachInst _machInst,
                const char * instMnem, uint64_t setFlags,
                InstRegIndex _src1, InstRegIndex _src2,
				uint16_t _imm8, InstRegIndex _dest,
                uint8_t _srcSize, uint8_t _destSize, uint16_t _ext);

        Fault execute(ExecContext *, Trace::InstRecord *) const;
    };
}};

def template AVXOpRegConstructor {{
    %(class_name)s::%(class_name)s(
            ExtMachInst machInst, const char * instMnem, uint64_t setFlags,
            InstRegIndex _src1, InstRegIndex _src2,
            InstRegIndex _src3, InstRegIndex _dest,
            uint8_t _srcSize, uint8_t _destSize, uint16_t _ext) :
        %(base_class)s(machInst, "%(mnemonic)s", instMnem, setFlags,
                _src1, _src2, _src3, _dest, _srcSize, _destSize, _ext,
                %(op_class)s)
    {
        %(constructor)s;
    }
}};

def template AVXOpImmConstructor {{
    %(class_name)s::%(class_name)s(
            ExtMachInst machInst, const char * instMnem, uint64_t setFlags,
            InstRegIndex _src1, InstRegIndex _src2,
			uint16_t _imm8, InstRegIndex _dest,
            uint8_t _srcSize, uint8_t _destSize, uint16_t _ext) :
        %(base_class)s(machInst, "%(mnemonic)s", instMnem, setFlags,
                _src1, _src2, _imm8, _dest, _srcSize, _destSize, _ext,
                %(op_class)s)
    {
        %(constructor)s;
    }
}};

let {{
    # Make these empty strings so that concatenating onto
    # them will always work.
    header_output = ""
    decoder_output = ""
    exec_output = ""

    immTemplates = (
            AVXOpImmDeclare,
            AVXOpImmConstructor,
            AVXOpExecute)

    regTemplates = (
            AVXOpRegDeclare,
            AVXOpRegConstructor,
            AVXOpExecute)

    class AVXOpMeta(type):
        def buildCppClasses(self, name, Name, suffix, code):

            # Globals to stick the output in
            global header_output
            global decoder_output
            global exec_output

            # If op2 is used anywhere, make register and immediate versions
            # of this code.
            matcher = re.compile(r"(?<!\w)(?P<prefix>s?)op2(?P<typeQual>_[^\W_]+)?")
            match = matcher.search(code)
            if match:
                typeQual = ""
                if match.group("typeQual"):
                    typeQual = match.group("typeQual")
                src3_name = "%sFpSrcReg3%s" % (match.group("prefix"), typeQual)
                self.buildCppClasses(name, Name, suffix,
                        matcher.sub(src3_name, code))
                self.buildCppClasses(name + "i", Name, suffix + "Imm",
                        matcher.sub("imm8", code))
                return

            base = "X86ISA::AVXOp"

            # If imm8 shows up in the code, use the immediate templates, if
            # not, hopefully the register ones will be correct.
            matcher = re.compile("(?<!\w)imm8(?!\w)")
            if matcher.search(code):
                base += "Imm"
                templates = immTemplates
            else:
                base += "Reg"
                templates = regTemplates

            # Get everything ready for the substitution
            opt_args = []
            if self.op_class:
                opt_args.append(self.op_class)
            iop = InstObjParams(name, Name + suffix, base, {"code" : code},
                                opt_args)

            # Generate the actual code (finally!)
            header_output += templates[0].subst(iop)
            decoder_output += templates[1].subst(iop)
            exec_output += templates[2].subst(iop)


        def __new__(mcls, Name, bases, dict):
            abstract = False
            name = Name.lower()
            if "abstract" in dict:
                abstract = dict['abstract']
                del dict['abstract']
            if not "op_class" in dict:
                dict["op_class"] = None

            cls = super(AVXOpMeta, mcls).__new__(mcls, Name, bases, dict)
            if not abstract:
                cls.className = Name
                cls.base_mnemonic = name
                code = cls.code

                # Set up the C++ classes
                mcls.buildCppClasses(cls, name, Name, "", code)

                # Hook into the microassembler dict
                global microopClasses
                microopClasses[name] = cls

                # If op2 is used anywhere, make register and immediate versions
                # of this code.
                matcher = re.compile(r"op2(?P<typeQual>_[^\W_]+)?")
                if matcher.search(code):
                    microopClasses[name + 'i'] = cls
            return cls

    @six.add_metaclass(AVXOpMeta)
    class AVXOp(X86Microop):
        # This class itself doesn't act as a microop
        abstract = True

        def __init__(self, dest, src1, src2, op2 = "InstRegIndex(0)",
                size = None, destSize = None, srcSize = None, ext = None):
            self.dest = dest
            self.src1 = src1
            self.src2 = src2
            self.op2 = op2

            self.srcSize = srcSize if srcSize is not None else 0
            self.destSize = destSize if destSize is not None else 0
            self.ext = ext if ext is not None else 0

            if size is not None:
                self.srcSize = size
                self.destSize = size
            else:
                self.size = 0

            if self.srcSize is None:
                raise Exception("Source size not set.")
            if self.destSize is None:
                raise Exception("Dest size not set.")

        def getAllocator(self, microFlags):
            className = self.className
            if self.mnemonic == self.base_mnemonic + 'i':
                className += "Imm"
            allocator = '''new %(class_name)s(machInst, macrocodeBlock,
                    %(flags)s, %(src1)s, %(src2)s, %(op2)s, %(dest)s,
                    %(srcSize)s, %(destSize)s, %(ext)s)''' % {
                    "class_name" : className,
                    "flags" : self.microFlagsText(microFlags),
                    "src1" : self.src1,
                    "src2" : self.src2,
                    "op2" : self.op2,
                    "dest" : self.dest,
                    "srcSize" : self.srcSize,
                    "destSize" : self.destSize,
                    "ext" : self.ext}
            return allocator

    class gem5_avx_get_epi32(AVXOp):
        op_class = 'No_OpClass'
        code = '''
            uint8_t index = SrcReg2_udw & mask(4);
            DestReg_sqw = VecSrcReg1_sdw[index];
        '''
#            uint32_t arg1Bits = VecSrcReg1_udw[index];
#            DestReg_uqw = ( bits(arg1Bits,31) ) ?
#                          (arg1Bits | 0xFFFFFFFF00000000) : (arg1Bits);
#            DestReg_udw = ( !signedOp() ) ? ( arg1Bits ) :
#                      ( arg1Bits | (0 - (arg1Bits & (ULL(1) << 31))) );

    class gem5_avx_get_epi64(AVXOp):
        op_class = 'No_OpClass'
        code = '''
            uint8_t index = SrcReg2_uqw & mask(3);
            DestReg_sqw = VecSrcReg1_sqw[index];
        '''
#            uint64_t arg1Bits = VecSrcReg1_uqw[index];
#            DestReg_uqw = arg1Bits;
#            DestReg_uqw = ( !signedOp() ) ? (arg1Bits ) :
#                      ( arg1Bits | (0 - (arg1Bits & (ULL(1) << 63))) );

    class gem5_avx_set_epi32(AVXOp):
        op_class = 'No_OpClass'
        code = '''
            VecDestReg_udw = VecSrcReg1_udw; 
            uint8_t index = SrcReg3_udw & mask(4);
            VecDestReg_udw[index] = SrcReg2_udw;
        '''

    class gem5_avx_set_epi64(AVXOp):
        op_class = 'No_OpClass'
        code = '''
            VecDestReg_uqw = VecSrcReg1_uqw;
            uint8_t index = SrcReg3_udw & mask(3);
            VecDestReg_uqw[index] = SrcReg2_uqw;
        '''


    class gem5_avx_add_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = VecSrcReg1_sf[0] + VecSrcReg2_sf[0];
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_add_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = VecSrcReg1_df[0] + VecSrcReg2_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_add_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = VecSrcReg1_sf[i] + VecSrcReg2_sf[i];
        '''

    class gem5_avx_add_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = VecSrcReg1_df[i] + VecSrcReg2_df[i];
        '''

#    class _mm256_add_epi8(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                sb32_dest_sb32[i] = sb32_src1_sb32[i] + sb32_src2_sb32[i];
#            for(int i=ext; i<32; i++)
#                sb32_dest_sb32[i] = 0;
#        '''
#
#    class _mm256_add_epi16(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                sw16_dest_sw16[i] = sw16_src1_sw16[i] + sw16_src2_sw16[i];
#            for(int i=ext; i<16; i++)
#                sw16_dest_sw16[i] = 0;
#        '''

    class gem5_avx_add_epu32(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = VecSrcReg1_udw[i] + VecSrcReg2_udw[i];
        '''

    class gem5_avx_add_epu64(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[i] + VecSrcReg2_uqw[i];
        '''

#    class _mm256_adds_epi8(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = ub32_src1_ub32[i];
#                uint64_t arg2Bits = ub32_src2_ub32[i];
#                uint64_t resBits = arg1Bits + arg2Bits;
#                int arg1Sign = (arg1Bits >> (sizeBits-1)) & 0x01;
#                int arg2Sign = (arg2Bits >> (sizeBits-1)) & 0x01;
#                int resSign  = (resBits  >> (sizeBits-1)) & 0x01;
#                if( (arg1Sign == arg2Sign) && (arg1Sign != resSign) )
#                    resBits  = (resSign == 0)  ? ( ULL(1) << (sizeBits-1) )
#                                               : mask(sizeBits - 1);
#                ub32_dest_ub32[i] = *((uint8_t *) &resBits);
#            }
#            for(int i=ext; i<32; i++)
#                ub32_dest_ub32[i] = 0;
#        '''
#
#    class _mm256_adds_epi16(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = uw16_src1_uw16[i];
#                uint64_t arg2Bits = uw16_src2_uw16[i];
#                uint64_t resBits = arg1Bits + arg2Bits;
#                int arg1Sign = (arg1Bits >> (sizeBits-1)) & 0x01;
#                int arg2Sign = (arg2Bits >> (sizeBits-1)) & 0x01;
#                int resSign  = (resBits  >> (sizeBits-1)) & 0x01;
#                if( (arg1Sign == arg2Sign) && (arg1Sign != resSign) )
#                    resBits  = (resSign == 0)  ? ( ULL(1) << (sizeBits-1) )
#                                               : mask(sizeBits - 1);
#                uw16_dest_uw16[i] = *((uint16_t *) &resBits);
#            }
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''
#
#    class _mm256_adds_epu8(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = ub32_src1_ub32[i];
#                uint64_t arg2Bits = ub32_src2_ub32[i];
#                uint64_t resBits = arg1Bits + arg2Bits;
#                if( arg2Bits > arg1Bits )
#                    resBits = 0;
#                else if( !findCarry(sizeBits, resBits, arg1Bits, ~arg2Bits) )
#                    resBits = mask(sizeBits);
#                ub32_dest_ub32[i] = *((uint8_t *) &resBits);
#            }
#            for(int i=ext; i<32; i++)
#                ub32_dest_ub32[i] = 0;
#        '''
#
#    class _mm256_adds_epu16(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = uw16_src1_uw16[i];
#                uint64_t arg2Bits = uw16_src2_uw16[i];
#                uint64_t resBits = arg1Bits + arg2Bits;
#                if( arg2Bits > arg1Bits )
#                    resBits = 0;
#                else if( !findCarry(sizeBits, resBits, arg1Bits, ~arg2Bits) )
#                    resBits = mask(sizeBits);
#                uw16_dest_uw16[i] = *((uint16_t *) &resBits);
#            }
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''

    class gem5_avx_sub_ss(AVXOp):
        op_class = 'FloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = VecSrcReg1_sf[0] - VecSrcReg2_sf[0];
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_sub_sd(AVXOp):
        op_class = 'FloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = VecSrcReg1_df[0] - VecSrcReg2_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_sub_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = VecSrcReg1_sf[i] - VecSrcReg2_sf[i];
        '''

    class gem5_avx_sub_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = VecSrcReg1_df[i] - VecSrcReg2_df[i];
        '''

    class gem5_avx_sub_epu8(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_ub = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                VecDestReg_ub[i] = VecSrcReg1_ub[i] - VecSrcReg2_ub[i];
        '''

    class gem5_avx_sub_epu16(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++)
                VecDestReg_uw[i] = VecSrcReg1_uw[i] - VecSrcReg2_uw[i];
        '''

    class gem5_avx_sub_epu32(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = VecSrcReg1_udw[i] - VecSrcReg2_udw[i];
        '''

    class gem5_avx_sub_epu64(AVXOp):
        op_class = 'SimdAddOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[i] - VecSrcReg2_uqw[i];
        '''

#    class _mm256_subs_epi8(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = ub32_src1_ub32[i];
#                uint64_t arg2Bits = ub32_src2_ub32[i];
#                uint64_t resBits = arg1Bits - arg2Bits;
#                int arg1Sign = (arg1Bits >> (sizeBits-1)) & 0x01;
#                int arg2Sign = (arg2Bits >> (sizeBits-1)) & 0x01;
#                int resSign  = (resBits  >> (sizeBits-1)) & 0x01;
#                if( (arg1Sign == arg2Sign) && (arg1Sign != resSign) )
#                    resBits  = (resSign == 0)  ? ( ULL(1) << (sizeBits-1) )
#                                               : mask(sizeBits - 1);
#                ub32_dest_ub32[i] = *((uint8_t *) &resBits);
#            }
#            for(int i=ext; i<32; i++)
#                ub32_dest_ub32[i] = 0;
#        '''
#
#    class _mm256_subs_epi16(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = uw16_src1_uw16[i];
#                uint64_t arg2Bits = uw16_src2_uw16[i];
#                uint64_t resBits = arg1Bits - arg2Bits;
#                int arg1Sign = (arg1Bits >> (sizeBits-1)) & 0x01;
#                int arg2Sign = (arg2Bits >> (sizeBits-1)) & 0x01;
#                int resSign  = (resBits  >> (sizeBits-1)) & 0x01;
#                if( (arg1Sign == arg2Sign) && (arg1Sign != resSign) )
#                    resBits  = (resSign == 0)  ? ( ULL(1) << (sizeBits-1) )
#                                               : mask(sizeBits - 1);
#                uw16_dest_uw16[i] = *((uint16_t *) &resBits);
#            }
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''
#
#    class _mm256_subs_epu8(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = ub32_src1_ub32[i];
#                uint64_t arg2Bits = ub32_src2_ub32[i];
#                uint64_t resBits = arg1Bits - arg2Bits;
#                if( arg2Bits > arg1Bits )
#                    resBits = 0;
#                else if( !findCarry(sizeBits, resBits, arg1Bits, ~arg2Bits) )
#                    resBits = mask(sizeBits);
#                ub32_dest_ub32[i] = *((uint8_t *) &resBits);
#            }
#            for(int i=ext; i<32; i++)
#                ub32_dest_ub32[i] = 0;
#        '''
#
#    class _mm256_subs_epu16(AVXOp):
#        op_class = 'SimdAddOp'
#        code = '''
#            int sizeBits = srcSize * 8;
#            for(int i=0; i<ext; i++) {
#                uint64_t arg1Bits = uw16_src1_uw16[i];
#                uint64_t arg2Bits = uw16_src2_uw16[i];
#                uint64_t resBits = arg1Bits - arg2Bits;
#                if( arg2Bits > arg1Bits )
#                    resBits = 0;
#                else if( !findCarry(sizeBits, resBits, arg1Bits, ~arg2Bits) )
#                    resBits = mask(sizeBits);
#                uw16_dest_uw16[i] = *((uint16_t *) &resBits);
#            }
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''

    class gem5_avx_mul_ss(AVXOp):
        op_class = 'FloatMultOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = VecSrcReg1_sf[0] * VecSrcReg2_sf[0];
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_mul_sd(AVXOp):
        op_class = 'FloatMultOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = VecSrcReg1_df[0] * VecSrcReg2_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_mul_ps(AVXOp):
        op_class = 'SimdFloatMultOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = VecSrcReg1_sf[i] * VecSrcReg2_sf[i];
        '''

    class gem5_avx_mul_pd(AVXOp):
        op_class = 'SimdFloatMultOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = VecSrcReg1_df[i] * VecSrcReg2_df[i];
        '''

    class gem5_avx_mul_epu64(AVXOp):
        op_class = 'SimdMultOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = VecSrcReg1_udw[i*2] * VecSrcReg2_udw[i*2];
        '''

    class gem5_avx_mul_epi64(AVXOp):
        op_class = 'SimdMultOp'
        code = '''
            VecDestReg_sqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_sqw[i] = (int64_t) VecSrcReg1_udw[i*2] *
                                    (int64_t) VecSrcReg2_udw[i*2];
        '''

    class gem5_avx_mullo_epi32(AVXOp):
        op_class = 'SimdMultOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                int32_t arg1 = VecSrcReg1_sdw[i];
                int32_t arg2 = VecSrcReg2_sdw[i];
                VecDestReg_udw[i] = (arg1 * arg2) & mask(32);
            }
        '''

    class gem5_avx_mullo_epi64(AVXOp):
        op_class = 'SimdMultOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                int64_t arg1 = VecSrcReg1_sqw[i];
                int64_t arg2 = VecSrcReg2_sqw[i];
                VecDestReg_uqw[i] = (arg1 * arg2) & mask(64);
            }
        '''

    class gem5_avx_madd_epi16(AVXOp):
        op_class = 'SimdMultOp'
        code = '''
            VecDestReg_sdw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sdw[i] = (VecSrcReg1_sw[2*i  ] * VecSrcReg2_sw[2*i  ])
                                  + (VecSrcReg1_sw[2*i+1] * VecSrcReg2_sw[2*i+1])
        '''

    class gem5_avx_div_ss(AVXOp):
        op_class = 'FloatDivOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = VecSrcReg1_sf[0] / VecSrcReg2_sf[0];
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_div_sd(AVXOp):
        op_class = 'FloatDivOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = VecSrcReg1_df[0] / VecSrcReg2_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_div_ps(AVXOp):
        op_class = 'SimdFloatDivOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = VecSrcReg1_sf[i] / VecSrcReg2_sf[i];
        '''

    class gem5_avx_div_pd(AVXOp):
        op_class = 'SimdFloatDivOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = VecSrcReg1_df[i] / VecSrcReg2_df[i];
        '''

    class gem5_avx_sqrt_ss(AVXOp):
        op_class = 'FloatSqrtOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = sqrt(VecSrcReg2_sf[0]);
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_sqrt_sd(AVXOp):
        op_class = 'FloatSqrtOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = sqrt(VecSrcReg2_df[0]);
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_sqrt_ps(AVXOp):
        op_class = 'SimdFloatSqrtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_sqrt_ps, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = sqrt(VecSrcReg1_sf[i]);
        '''

    class gem5_avx_sqrt_pd(AVXOp):
        op_class = 'SimdFloatSqrtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_sqrt_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = sqrt(VecSrcReg1_df[i]);
        '''

#    class _mm256_rsqrt_ss(AVXOp):
#        op_class = 'FloatSqrtOp'
#        code = '''
#            sf8_dest_sf8 = (float8) { 1.0f / sqrtf(sf4_src2_sf4[0]),
#                                   sf4_src1_sf4[1],
#                                   sf4_src1_sf4[2],
#                                   sf4_src1_sf4[3],
#                                   0.0, 0.0, 0.0, 0.0};
#        '''
#
#    class _mm256_rsqrt_sd(AVXOp):
#        op_class = 'FloatSqrtOp'
#        code = '''
#            df4_dest_df4 = (double4) {1.0 / sqrt(df2_src2_df2[0]),
#                                    df2_src1_df2[1], 0.0, 0.0};
#        '''
#
#    class _mm256_rsqrt_ps(AVXOp):
#        op_class = 'SimdFloatSqrtOp'
#        def __init__(self, dest, src, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm256_rsqrt_ps, self).__init__(dest, src,\
#                    "InstRegIndex(0)", "InstRegIndex(0)", size, destSize, srcSize, ext)
#        code = '''
#            for(int i=0; i<ext; i++)
#                sf8_dest_sf8[i] = 1.0 / sqrt(sf8_src1_sf8[i]);
#            for(int i=ext; i<8; i++)
#                sf8_dest_sf8[i] = 0.0;
#        '''
#
#    class _mm256_rsqrt_pd(AVXOp):
#        op_class = 'SimdFloatSqrtOp'
#        def __init__(self, dest, src, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm256_rsqrt_pd, self).__init__(dest, src,\
#                    "InstRegIndex(0)", "InstRegIndex(0)", size, destSize, srcSize, ext)
#        code = '''
#            for(int i=0; i<ext; i++)
#                df4_dest_df4[i] = 1.0 / sqrt(df4_src1_df4[i]);
#            for(int i=ext; i<4; i++)
#                df4_dest_df4[i] = 0.0;
#        '''

    class gem5_avx_rsqrt14_pd(AVXOp):
        op_class = 'SimdFloatSqrtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_rsqrt14_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0.0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = RSQRT14D_APPROXIMATE(VecSrcReg1_df[i]);
        '''
#                VecDestReg_df[i] = 1.0 / sqrt(VecSrcReg1_df[i]);


#                floatInt fi;
#                fi.i = Iu32xMaxSrc1_maxudw[i];
#                Iu32xMaxDest_maxudw[i] = pow(fi.f,-1.0);
#                Iu32xMaxDest_maxudw[i] =
#                            (0xbe6eb3beU - Iu32xMaxSrc1_maxudw[i]) >> 1;

    class gem5_mm256_rcp_ss(AVXOp):
        op_class = 'FloatDivOp'
        code = '''
            floatInt fi;
            fi.i = VecSrcReg2_udw[0];

            uint64_t regs[2];
            asm volatile(\"movups %1, %%xmm1 \\n\"
                         \"rcpss %%xmm1, %%xmm0 \\n\"
                         \"movups %%xmm0, %0\" : \"=m\" (regs) : \"m\" (fi.i));

            VecDestReg_udw = { 0 };
            VecDestReg_udw[0] = regs[0];
            VecDestReg_udw[1] = VecSrcReg1_udw[1];
            VecDestReg_udw[2] = VecSrcReg1_udw[2];
            VecDestReg_udw[3] = VecSrcReg1_udw[3];
        '''

    class gem5_mm256_rcp_ps(AVXOp):
        op_class = 'SimdFloatSqrtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_rcp_ps, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = ymmOp() ? 8 : 4;
            for(int i=0; i<count; i++) {
                floatInt fi;
                fi.i = VecSrcReg1_udw[i];
                //fi.f = 1.0 / fi.f;
                uint64_t regs[2];
                asm volatile(\"movups %1, %%xmm1 \\n\"
                             \"rcpss %%xmm1, %%xmm0 \\n\"
                             \"movups %%xmm0, %0\" : \"=m\" (regs) : \"m\" (fi.i));
                //Iu32xMaxDest_maxudw[i] = fi.i;
                VecDestReg_udw[i] = regs[0];
            }
        '''

    class gem5_avx_rcp14_pd(AVXOp):
        op_class = 'SimdFloatSqrtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_rcp14_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0.0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = RCP14D_APPROXIMATE(VecSrcReg1_df[i]);

        '''
#                VecDestReg_df[i] = 1.0 / VecSrcReg1_df[i];

    class gem5_avx_addsub_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = ymmOp() ? 8 : 4;
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = VecSrcReg1_sf[i] +
                        ( (i%2) ? VecSrcReg2_sf[i] : -VecSrcReg2_sf[i] );
        '''

    class gem5_avx_addsub_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = ymmOp() ? 4 : 2;
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = VecSrcReg1_df[i] + 
                        ( (i%2) ? VecSrcReg2_df[i] : -VecSrcReg2_df[i] );
        '''

    class gem5_avx_dp_ps(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_sf = { 0 };
            float result = 0.0;
            for(int i=0; i<4; i++)
                if( (ext >> (i+4)) & mask(1) )
                    result += (VecSrcReg1_sf[i] * VecSrcReg2_sf[i]);
            for(int i=0; i<4; i++)
                VecDestReg_sf[i] = ((ext >> i) & mask(1)) ? result : 0;
            if( ymmOp() ) {
                for(int i=4; i<8; i++)
                    if( (ext >> i) & mask(1) )
                        result += (VecSrcReg1_sf[i] * VecSrcReg2_sf[i]);
                for(int i=4; i<8; i++)
                    VecDestReg_sf[i] = ((ext >> (i-4)) & mask(1)) ? result : 0;
            }
        '''

    class gem5_avx_dp_pd(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_df = { 0 };
            double result = 0.0;
            for(int i=0; i<2; i++)
                if( (ext >> (i+4)) & mask(1) )
                    result += (VecSrcReg1_df[i] * VecSrcReg2_df[i]);
            for(int i=0; i<2; i++)
                VecDestReg_df[i] = ((ext >> i) & mask(1)) ? result : 0;
        '''

    class gem5_avx_max_ss(AVXOp):
        op_class = 'FloatCmpOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (VecSrcReg1_sf[0] >=  VecSrcReg2_sf[0]) ?
                               (VecSrcReg1_sf[0]) : (VecSrcReg2_sf[0]);
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_max_sd(AVXOp):
        op_class = 'FloatMultOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (VecSrcReg1_df[0] >=  VecSrcReg2_df[0]) ?
                               (VecSrcReg1_df[0]) : (VecSrcReg2_df[0]);
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_max_ps(AVXOp):
        op_class = 'SimdFloatCmpOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = (VecSrcReg1_sf[i] >=  VecSrcReg2_sf[i]) ?
                                   (VecSrcReg1_sf[i]) : (VecSrcReg2_sf[i]);
        '''

    class gem5_avx_max_pd(AVXOp):
        op_class = 'SimdFloatCmpOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = (VecSrcReg1_df[i] >=  VecSrcReg2_df[i]) ?
                                   (VecSrcReg1_df[i]) : (VecSrcReg2_df[i]);
        '''

    class gem5_avx_max_epi8(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sb = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++) {
                int8_t arg1 = VecSrcReg1_sb[i];
                int8_t arg2 = VecSrcReg2_sb[i];
                VecDestReg_sb[i] = (arg1 > arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_max_epi16(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++) {
                int16_t arg1 = VecSrcReg1_sw[i];
                int16_t arg2 = VecSrcReg2_sw[i];
                VecDestReg_sw[i] = (arg1 > arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_max_epi32(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sdw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                int32_t arg1 = VecSrcReg1_sdw[i];
                int32_t arg2 = VecSrcReg2_sdw[i];
                VecDestReg_sdw[i] = (arg1 > arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_max_epi64(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                int64_t arg1 = VecSrcReg1_sqw[i];
                int64_t arg2 = VecSrcReg2_sqw[i];
                VecDestReg_sqw[i] = (arg1 > arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_min_ss(AVXOp):
        op_class = 'FloatCmpOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (VecSrcReg1_sf[0] <   VecSrcReg2_sf[0]) ?
                               (VecSrcReg1_sf[0]) : (VecSrcReg2_sf[0]);
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_min_sd(AVXOp):
        op_class = 'FloatCmpOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (VecSrcReg1_df[0] <   VecSrcReg2_df[0]) ?
                               (VecSrcReg1_df[0]) : (VecSrcReg2_df[0]);
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_min_ps(AVXOp):
        op_class = 'SimdFloatCmpOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = (VecSrcReg1_sf[i] <   VecSrcReg2_sf[i]) ?
                                   (VecSrcReg1_sf[i]) : (VecSrcReg2_sf[i]);
        '''

    class gem5_avx_min_pd(AVXOp):
        op_class = 'SimdFloatCmpOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = (VecSrcReg1_df[i] <   VecSrcReg2_df[i]) ?
                                   (VecSrcReg1_df[i]) : (VecSrcReg2_df[i]);
        '''

    class gem5_avx_min_epu8(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_ub = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++) {
                uint8_t arg1 = VecSrcReg1_ub[i];
                uint8_t arg2 = VecSrcReg2_ub[i];
                VecDestReg_ub[i] = (arg1 < arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_min_epi32(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sdw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                int32_t arg1 = VecSrcReg1_sdw[i];
                int32_t arg2 = VecSrcReg2_sdw[i];
                VecDestReg_sdw[i] = (arg1 < arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_min_epi64(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            VecDestReg_sqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                int64_t arg1 = VecSrcReg1_sqw[i];
                int64_t arg2 = VecSrcReg2_sqw[i];
                VecDestReg_sqw[i] = (arg1 < arg2) ? arg1 : arg2;
            }
        '''

    class gem5_avx_and_epu32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1 = VecSrcReg1_udw[i];
                uint32_t arg2 = VecSrcReg2_udw[i];
                VecDestReg_udw[i] = arg1 & arg2;
            }
        '''

    class gem5_avx_and_epu64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint64_t arg2 = VecSrcReg2_uqw[i];
                VecDestReg_uqw[i] = arg1 & arg2;
            }
        '''

    class gem5_avx_andn_epu32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1 = VecSrcReg1_udw[i];
                uint32_t arg2 = VecSrcReg2_udw[i];
                VecDestReg_udw[i] = ~arg1 & arg2;
            }
        '''

    class gem5_avx_andn_epu64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint64_t arg2 = VecSrcReg2_uqw[i];
                VecDestReg_uqw[i] = ~arg1 & arg2;
            }
        '''

    class gem5_avx_or_epu32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1 = VecSrcReg1_udw[i];
                uint32_t arg2 = VecSrcReg2_udw[i];
                VecDestReg_udw[i] = arg1 | arg2;
            }
        '''

    class gem5_avx_or_epu64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint64_t arg2 = VecSrcReg2_uqw[i];
                VecDestReg_uqw[i] = arg1 | arg2;
            }
        '''

    class gem5_avx_xor_epu32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1 = VecSrcReg1_udw[i];
                uint32_t arg2 = VecSrcReg2_udw[i];
                VecDestReg_udw[i] = arg1 ^ arg2;
            }
        '''

    class gem5_avx_xor_epu64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint64_t arg2 = VecSrcReg2_uqw[i];
                VecDestReg_uqw[i] = arg1 ^ arg2;
            }
        '''

    class gem5_avx_round_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            uint64_t RoundMode = op2_uqw & mask(2);
            float farg1 = VecSrcReg2_sf[0];
            int32_t iarg = 0;
            switch(RoundMode) {
            case 0:
                iarg = round(farg1);
                if( (farg1-iarg) == 0.5 )
                    iarg = (iarg / 2) * 2;
                break;
            case 1:
                iarg = floor(farg1);
                break;
            case 2:
                iarg = ceil(farg1);
                break;
            case 3:
                iarg = (farg1 >= 0.0) ? floor(farg1) : ceil(farg1);
                break;
            }
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = iarg;
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_round_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            uint64_t RoundMode = op2_uqw & mask(2);
            double darg1 = VecSrcReg2_df[0];
            int64_t iarg = 0;
            switch(RoundMode) {
            case 0:
                iarg = round(darg1);
                if( (darg1-iarg) == 0.5 )
                    iarg = (iarg / 2) * 2;
                break;
            case 1:
                iarg = floor(darg1);
                break;
            case 2:
                iarg = ceil(darg1);
                break;
            case 3:
                iarg = (darg1 >= 0.0) ? floor(darg1) : ceil(darg1);
                break;
            }
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = iarg;
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_round_ps(AVXOp):
        op_class = 'SimdFloatAluOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_round_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            uint64_t RoundMode = op2_uqw & mask(2);
            VecDestReg_sf = { 0 };
            int count = ymmOp() ? 8 : 4;
            for(int i=0; i<count; i++) {
                float farg1 = VecSrcReg1_sf[i];
                int32_t iarg = 0;
                switch(RoundMode) {
                case 0:
                    iarg = round(farg1);
                    if( (farg1-iarg) == 0.5 ) iarg = (iarg / 2) * 2;
                    break;
                case 1:
                    iarg = floor(farg1);
                    break;
                case 2:
                    iarg = ceil(farg1);
                    break;
                case 3:
                    iarg = (farg1 >= 0.0) ? floor(farg1) : ceil(farg1);
                    break;
                }
                VecDestReg_sf[i] = iarg;
            }
        '''

    class gem5_avx_round_pd(AVXOp):
        op_class = 'SimdFloatAluOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_round_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            uint64_t RoundMode = op2_uqw & mask(2);
            VecDestReg_df = { 0 };
            int count = ymmOp() ? 4 : 2;
            for(int i=0; i<count; i++) {
                double darg1 = VecSrcReg1_df[i];
                int64_t iarg = 0;
                switch(RoundMode) {
                case 0:
                    iarg = round(darg1);
                    if( (darg1-iarg) == 0.5 ) iarg = (iarg / 2) * 2;
                    break;
                case 1:
                    iarg = floor(darg1);
                    break;
                case 2:
                    iarg = ceil(darg1);
                    break;
                case 3:
                    iarg = (darg1 >= 0.0) ? floor(darg1) : ceil(darg1);
                    break;
                }
                VecDestReg_df[i] = iarg;
            }
        '''

    class gem5_evex_roundscale_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            uint64_t scale_factor = (op2_uqw >> 4) & mask(4);
            uint64_t RoundMode = ( op2_uqw & 0x4 ) ?
                                 (0) : // FIXME: get round control from MXCSR
                                 (op2_uqw & mask(2));
            float ftemp = VecSrcReg2_sf[0];
            for(int i=0; i<scale_factor; i++) ftemp *= 2;
            switch(RoundMode) {
            case 0: ftemp = ceil(ftemp/2) * 2; break;
            case 1: ftemp = floor(ftemp); break;
            case 2: ftemp = ceil(ftemp); break;
            case 3: ftemp = (ftemp < 0.0) ? ceil(ftemp) : floor(ftemp); break;
            }
            for(int i=0; i<scale_factor; i++) ftemp /= 2;
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = ftemp;
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_evex_roundscale_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            uint64_t scale_factor = (op2_uqw >> 4) & mask(4);
            uint64_t RoundMode = ( op2_uqw & 0x4 ) ?
                                 (0) : // FIXME: get round control from MXCSR
                                 (op2_uqw & mask(2));
            double dtemp = VecSrcReg2_df[0];
            for(int i=0; i<scale_factor; i++) dtemp *= 2;
            switch(RoundMode) {
            case 0: dtemp = ceil(dtemp/2) * 2; break;
            case 1: dtemp = floor(dtemp); break;
            case 2: dtemp = ceil(dtemp); break;
            case 3: dtemp = (dtemp < 0.0) ? ceil(dtemp) : floor(dtemp); break;
            }
            for(int i=0; i<scale_factor; i++) dtemp /= 2;
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = dtemp;
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_evex_roundscale_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_roundscale_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint64_t scale_factor = (op2_uqw >> 4) & mask(4);
                uint64_t RoundMode = ( op2_uqw & 0x4 ) ?
                                     (0) : // FIXME: get round control from MXCSR
                                     (op2_uqw & mask(2));
                float ftemp = VecSrcReg1_sf[i];
                for(int j=0; j<scale_factor; j++) ftemp *= 2;
                switch(RoundMode) {
                case 0: ftemp = ceil(ftemp/2) * 2; break;
                case 1: ftemp = floor(ftemp); break;
                case 2: ftemp = ceil(ftemp); break;
                case 3: ftemp = (ftemp < 0.0) ? ceil(ftemp) : floor(ftemp); break;
                }
                for(int j=0; j<scale_factor; j++) ftemp /= 2;
                VecDestReg_sf[i] = ftemp;
            }
        '''

    class gem5_evex_roundscale_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_roundscale_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint64_t scale_factor = (op2_uqw >> 4) & mask(4);
                uint64_t RoundMode = ( op2_uqw & 0x4 ) ?
                                     (0) : // FIXME: get round control from MXCSR
                                     (op2_uqw & mask(2));
                double dtemp = VecSrcReg1_df[i];
                for(int j=0; j<scale_factor; j++) dtemp *= 2;
                switch(RoundMode) {
                case 0: dtemp = ceil(dtemp/2) * 2; break;
                case 1: dtemp = floor(dtemp); break;
                case 2: dtemp = ceil(dtemp); break;
                case 3: dtemp = (dtemp < 0.0) ? ceil(dtemp) : floor(dtemp); break;
                }
                for(int j=0; j<scale_factor; j++) dtemp /= 2;
                VecDestReg_df[i] = dtemp;
            }
        '''

    class gem5_avx_cmpeq_epu8(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_ub = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                if(VecSrcReg1_ub[i] == VecSrcReg2_ub[i])
                    VecDestReg_ub[i] = mask(8);
        '''

#    class _mm256_cmpeq_epi16(AVXOp):
#        op_class = 'SimdCvtOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                sw16_dest_sw16[i] = (sw16_src1_sw16[i] == sw16_src2_sw16[i]) ?
#					(0xffff) : (0x0);
#			for(int i=ext; i<16; i++)
#            	sw16_dest_sw16[i] = 0;
#        '''

    class gem5_avx_cmpeq_epu32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_udw[i] == VecSrcReg2_udw[i] )
                    VecDestReg_udw[i] = mask(32);
        '''

    class gem5_avx_cmpeq_epu64(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_uqw[i] == VecSrcReg2_uqw[i] )
                    VecDestReg_uqw[i] = mask(64);
        '''

    class gem5_avx_cmpgt_epi8(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_sb = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                if(VecSrcReg1_sb[i] >= VecSrcReg2_sb[i])
                    VecDestReg_sb[i] = mask(8);
        '''

#    class _mm256_cmpgt_epi16(AVXOp):
#        op_class = 'SimdCvtOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                sw16_dest_sw16[i] = (sw16_src1_sw16[i] > sw16_src2_sw16[i]) ?
#					(0xffff) : (0x0);
#			for(int i=ext; i<16; i++)
#                sw16_dest_sw16[i] = 0;
#        '''

    class gem5_avx_cmpgt_epi32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_sdw[i] > VecSrcReg2_sdw[i] )
                    VecDestReg_udw[i] = mask(32);
        '''

    class gem5_avx_cmpgt_epi64(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_sqw[i] > VecSrcReg2_sqw[i] )
                    VecDestReg_uqw[i] = mask(64);
        '''

    class gem5_evex_cmpeq_epi8(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                if(VecSrcReg1_sb[i] == VecSrcReg2_sb[i])
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_cmpeq_epi32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_sdw[i] == VecSrcReg2_sdw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_cmpgt_epi32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_sdw[i] > VecSrcReg2_sdw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_cmpgt_epi64(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_sqw[i] > VecSrcReg2_sqw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_cmp_epi32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            int select_op = ext & mask(3);
            int res = 0;
            for(int i=0; i<count; i++) {
                int32_t arg1 = VecSrcReg1_sdw[i];
                int32_t arg2 = VecSrcReg2_sdw[i];
                switch( select_op ) {
                    case 0: res = (arg1 == arg2); break;
                    case 1: res = (arg1 <  arg2); break;
                    case 2: res = (arg1 <= arg2); break;
                    // FIXME: need to check
                    case 3: res = 0;              break;
                    case 4: res = (arg1 != arg2); break;
                    case 5: res = (arg1 >= arg2); break;
                    case 6: res = (arg1 >  arg2); break;
                    // FIXME: need to check
                    case 7: res = 1;              break;
                }
                if( res ) OpMaskDestReg |= (mask(1) << i);
            }
        '''

    class gem5_evex_cmp_epu32(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            int select_op = ext & mask(3);
            int res = 0;
            for(int i=0; i<count; i++) {
                uint32_t arg1 = VecSrcReg1_udw[i];
                uint32_t arg2 = VecSrcReg2_udw[i];
                switch( select_op ) {
                    case 0: res = (arg1 == arg2); break;
                    case 1: res = (arg1 <  arg2); break;
                    case 2: res = (arg1 <= arg2); break;
                    // FIXME: need to check
                    case 3: res = 0;              break;
                    case 4: res = (arg1 != arg2); break;
                    case 5: res = (arg1 >= arg2); break;
                    case 6: res = (arg1 >  arg2); break;
                    // FIXME: need to check
                    case 7: res = 1;              break;
                }
                if( res ) OpMaskDestReg |= (mask(1) << i);
            }
        '''

    class gem5_evex_cmp_epi64(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            int select_op = ext & mask(3);
            int res = 0;
            for(int i=0; i<count; i++) {
                int64_t arg1 = VecSrcReg1_sqw[i];
                int64_t arg2 = VecSrcReg2_sqw[i];
                switch( select_op ) {
                    case 0: res = (arg1 == arg2); break;
                    case 1: res = (arg1 <  arg2); break;
                    case 2: res = (arg1 <= arg2); break;
                    // FIXME: need to check
                    case 3: res = 0;              break;
                    case 4: res = (arg1 != arg2); break;
                    case 5: res = (arg1 >= arg2); break;
                    case 6: res = (arg1 >  arg2); break;
                    // FIXME: need to check
                    case 7: res = 1;              break;
                }
                if( res ) OpMaskDestReg |= (mask(1) << i);
            }
        '''

    class gem5_evex_cmp_epu64(AVXOp):
        op_class = 'SimdCvtOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            int select_op = ext & mask(3);
            int res = 0;
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint64_t arg2 = VecSrcReg2_uqw[i];
                switch( select_op ) {
                    case 0: res = (arg1 == arg2); break;
                    case 1: res = (arg1 <  arg2); break;
                    case 2: res = (arg1 <= arg2); break;
                    // FIXME: need to check
                    case 3: res = 0;              break;
                    case 4: res = (arg1 != arg2); break;
                    case 5: res = (arg1 >= arg2); break;
                    case 6: res = (arg1 >  arg2); break;
                    // FIXME: need to check
                    case 7: res = 1;              break;
                }
                if( res ) OpMaskDestReg |= (mask(1) << i);
            }
        '''

    class gem5_evex_test_epi8(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_ub[i] & VecSrcReg2_ub[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_test_epi16(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_uw[i] & VecSrcReg2_uw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_test_epi32(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_udw[i] & VecSrcReg2_udw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_test_epi64(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                if( VecSrcReg1_uqw[i] & VecSrcReg2_uqw[i] )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_testn_epi8(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++)
                if( !(VecSrcReg1_ub[i] & VecSrcReg2_ub[i]) )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_testn_epi16(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++)
                if( !(VecSrcReg1_uw[i] & VecSrcReg2_uw[i]) )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_testn_epi32(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                if( !(VecSrcReg1_udw[i] & VecSrcReg2_udw[i]) )
                    OpMaskDestReg |= mask(1) << i;
        '''

    class gem5_evex_testn_epi64(AVXOp):
        op_class = 'SimdCmpOp'
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                if( !(VecSrcReg1_uqw[i] & VecSrcReg2_uqw[i]) )
                    OpMaskDestReg |= mask(1) << i;
        '''

#    class _mm256_cmp_ss(AVXOp):
#        op_class = 'FloatCvtOp'
#        code = '''
#            v128 v_arg1, v_arg2;
#            v_arg1._udw4 = udw4_src1_udw4;
#            v_arg2._uqw2 = (ulong2) {FpSrcReg2_uqw,0};
#            float4 v4sf_arg2 = ( ext & 0x20 ) ? ( v_arg2._sf4 ) : (sf4_src2_sf4);
#            int sizeBits = srcSize * 8;
#            //for(int i=0; i<1; i++) {
#                float arg1 = v_arg1._sf4[0];
#                float arg2 = v4sf_arg2[0];
#                bool nanop = std::isnan(arg1) || std::isnan(arg2);
#                uint32_t resBits = 0;
#                switch( ext & mask(5)) {
#                case 0x0:
#                case 0x8:
#                case 0x10:
#                case 0x18:
#                    if( arg1 == arg2 && !nanop )
#                        resBits = mask(sizeBits);
#                    break;
#                case 0x1:
#                case 0x9:
#                case 0x11:
#                case 0x19:
#                    if( arg1 < arg2 && !nanop )
#                        resBits = mask(sizeBits);
#                    break;
#                case 0x2:
#                case 0xA:
#                case 0x12:
#                case 0x1A:
#                    if( arg1 <= arg2 && !nanop )
#                        resBits = mask(sizeBits);
#                    break;
#                case 0x3:
#                case 0xB:
#                case 0x13:
#                case 0x1B:
#                    if( nanop )
#                        resBits = mask(sizeBits);
#                    break;
#                case 0x4:
#                case 0xC:
#                case 0x14:
#                case 0x1C:
#                    if (arg1 != arg2 || nanop)
#                        resBits = mask(sizeBits);
#                    break;
#               case 0x5:
#               case 0xD:
#               case 0x15:
#               case 0x1D:
#                    if (!(arg1 < arg2) || nanop)
#                        resBits = mask(sizeBits);
#                    break;
#               case 0x6:
#               case 0xE:
#               case 0x16:
#               case 0x1E:
#                    if (!(arg1 <= arg2) || nanop)
#                        resBits = mask(sizeBits);
#                    break;
#               case 0x7:
#               case 0xF:
#               case 0x17:
#               case 0x1F:
#                    if (!nanop)
#                        resBits = mask(sizeBits);
#                    break;
#                };
#                udw8_dest_udw8 = (uint8) {resBits, udw4_src1_udw4[1], udw4_src1_udw4[2],
#                        udw4_src1_udw4[3], 0, 0, 0, 0};
#            //}
#        '''

    class gem5_avx_cmp_sd(AVXOp):
        op_class = 'SimdFloatCvtOp'
        code = '''
            int sizeBits = srcSize * 8;
            double arg1 = VecSrcReg1_df[0];
            double arg2 = VecSrcReg2_df[0];
            bool nanop = std::isnan(arg1) || std::isnan(arg2);
            uint64_t resBits = 0;
            switch( ext & mask(3)) {
            case 0x0:
                if( arg1 == arg2 && !nanop )
                    resBits = mask(sizeBits);
                break;
            case 0x1:
                if( arg1 < arg2 && !nanop )
                    resBits = mask(sizeBits);
                break;
            case 0x2:
                if( arg1 <= arg2 && !nanop )
                    resBits = mask(sizeBits);
                break;
            case 0x3:
                if( nanop )
                    resBits = mask(sizeBits);
                break;
            case 0x4:
                if (arg1 != arg2 || nanop)
                    resBits = mask(sizeBits);
                break;
           case 0x5:
                if (!(arg1 < arg2) || nanop)
                    resBits = mask(sizeBits);
                break;
           case 0x6:
                if (!(arg1 <= arg2) || nanop)
                    resBits = mask(sizeBits);
                break;
           case 0x7:
                if (!nanop)
                    resBits = mask(sizeBits);
                break;
            };
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = resBits;
            VecDestReg_uqw[1] = *((uint64_t *) &VecSrcReg1_df[1]);
        '''

    class gem5_avx_cmp_ps(AVXOp):
        op_class = 'SimdFloatCvtOp'
        code = '''
            int sizeBits = srcSize * 8;
            int cnt = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            VecDestReg_udw = { 0 };
            const float min_normal = 1.17549435e-38;
            for(int i=0; i<cnt; i++) {
                float arg1 = VecSrcReg1_sf[i];
                float arg2 = VecSrcReg2_sf[i];
                bool nanop = std::isnan(arg1) || std::isnan(arg2);
                uint32_t resBits = 0;
                switch( ext & mask(3)) {
                case 0x0:
                    if( (fabs(arg1 - arg2) < min_normal) && !nanop )
                        resBits = mask(sizeBits);
                    break;
                case 0x1:
                    if( arg1 < arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x2:
                    if( arg1 <= arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x3:
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x4:
                    if (arg1 != arg2 || nanop) resBits = mask(sizeBits);
                    break;
               case 0x5:
                    if (!(arg1 < arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x6:
                    if (!(arg1 <= arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x7:
                    if (!nanop) resBits = mask(sizeBits);
                    break;
                };
                VecDestReg_udw[i] = resBits;
            }
        '''

    class gem5_avx_cmp_pd(AVXOp):
        op_class = 'SimdFloatCvtOp'
        code = '''
            int sizeBits = srcSize * 8;
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            VecDestReg_uqw = { 0 };
            const double min_normal = 2.2250738585072014e-308;
            for(int i=0; i<cnt; i++) {
                double arg1 = VecSrcReg1_df[i];
                double arg2 = VecSrcReg2_df[i];
                bool nanop = std::isnan(arg1) || std::isnan(arg2);
                uint64_t resBits = 0;
                switch( ext & mask(3)) {
                case 0x0:
                    if( (abs(arg1-arg2) < min_normal) && !nanop )
                        resBits = mask(sizeBits);
                    break;
                case 0x1:
                    if( arg1 < arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x2:
                    if( arg1 <= arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x3:
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x4:
                    if (arg1 != arg2 || nanop) resBits = mask(sizeBits);
                    break;
               case 0x5:
                    if (!(arg1 < arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x6:
                    if (!(arg1 <= arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x7:
                    if (!nanop) resBits = mask(sizeBits);
                    break;
                };
                VecDestReg_uqw[i] = resBits;
            }
        '''

    class gem5_evex_cmp_ps(AVXOp):
        op_class = 'SimdFloatCvtOp'
        code = '''
            int sizeBits = 1;
            int cnt = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            OpMaskDestReg = 0;
            for(int i=0; i<cnt; i++) {
                float arg1 = VecSrcReg1_sf[i];
                float arg2 = VecSrcReg2_sf[i];
                bool nanop = std::isnan(arg1) || std::isnan(arg2);
                uint64_t resBits = 0;
                switch( ext & mask(3)) {
                case 0x0:
                    if( arg1 == arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x1:
                    if( arg1 < arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x2:
                    if( arg1 <= arg2 && !nanop ) resBits = mask(sizeBits);
                    break;
                case 0x3:
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x4:
                    if (arg1 != arg2 || nanop) resBits = mask(sizeBits);
                    break;
               case 0x5:
                    if (!(arg1 < arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x6:
                    if (!(arg1 <= arg2) || nanop) resBits = mask(sizeBits);
                    break;
               case 0x7:
                    if (!nanop) resBits = mask(sizeBits);
                    break;
                };
                OpMaskDestReg |= ( resBits << i );
            }
        '''

    class gem5_evex_cmp_pd(AVXOp):
        op_class = 'SimdFloatCvtOp'
        code = '''
            int sizeBits = 1;
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            OpMaskDestReg = 0;
            for(int i=0; i<cnt; i++) {
                double arg1 = VecSrcReg1_df[i];
                double arg2 = VecSrcReg2_df[i];
                bool nanop = std::isnan(arg1) || std::isnan(arg2);
                uint64_t resBits = 0;
                switch(ext & mask(5)) {
                case 0x00:
                case 0x10:
                    if ( arg1 == arg2 ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x01:
                case 0x11:
                    if ( arg1 < arg2 ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x02:
                case 0x12:
                    if ( arg1 <= arg2 ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x03:
                case 0x13:
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x04:
                case 0x14:
                    if ( !(arg1 == arg2) ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x05:
                case 0x15:
                    if ( !(arg1 < arg2) ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x06:
                case 0x16:
                    if ( !(arg1 <= arg2) ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x07:
                case 0x17:
                    if (!nanop) resBits = mask(sizeBits);
                    break;
                case 0x08:
                case 0x18:
                    if ( arg1 == arg2 ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x09:
                case 0x19:
                    if ( arg1 < arg2 ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x0A:
                case 0x1A:
                    if ( arg1 <= arg2 ) resBits = mask(sizeBits);
                    if( nanop ) resBits = mask(sizeBits);
                    break;
                case 0x0B:
                case 0x1B:
                    // do nothing
                    break;
                case 0x0C:
                case 0x1C:
                    if ( !(arg1 == arg2) ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x0D:
                case 0x1D:
                    if ( !(arg1 < arg2) ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x0E:
                case 0x1E:
                    if ( !(arg1 <= arg2) ) resBits = mask(sizeBits);
                    if ( nanop ) resBits = 0;
                    break;
                case 0x0F:
                case 0x1F:
                    resBits = mask(sizeBits);
                    break;
                };
                OpMaskDestReg |= ( resBits << i );
            }
        '''

    class gem5_avx_sra_epi16(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            int sizeBits = srcSize * 8;
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++) {
                uint16_t arg1Bits = VecSrcReg1_uw[i];
                uint16_t resBits;
                if( shiftAmt >= sizeBits )
                    resBits = (bits(arg1Bits, sizeBits-1)) ? mask(sizeBits) : 0;
                else {
                    resBits = arg1Bits >> shiftAmt;
                    resBits |= (0 - (resBits & (ULL(1) << (sizeBits-1-shiftAmt))));
                }
                VecDestReg_uw[i] = resBits;
            }
        '''

    class gem5_avx_srai_epi16(AVXOp):
        op_class = 'SimdShiftOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_srai_epi16, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            int sizeBits = srcSize * 8;
            uint64_t shiftAmt = op2_uqw;
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);

            for(int i=0; i<count; i++) {
                uint16_t arg1Bits = VecSrcReg1_uw[i];
                uint16_t resBits;
                if( shiftAmt >= sizeBits )
                    resBits = (bits(arg1Bits, sizeBits-1)) ? mask(sizeBits) : 0;
                else {
                    resBits = arg1Bits >> shiftAmt;
                    resBits |= (0 - (resBits & (ULL(1) << (sizeBits-1-shiftAmt))));
                }
                VecDestReg_uw[i] = resBits;
            }
        '''

    class gem5_avx_sra_epi32(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            int sizeBits = srcSize * 8;
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1Bits = VecSrcReg1_udw[i];
                uint32_t resBits;
                if( shiftAmt >= sizeBits )
                    resBits = (bits(arg1Bits, sizeBits-1)) ? mask(sizeBits) : 0;
                else {
                    resBits = arg1Bits >> shiftAmt;
                    resBits |= (0 - (resBits & (ULL(1) << (sizeBits-1-shiftAmt))));
                }
                VecDestReg_udw[i] = resBits;
            }
        '''

    class gem5_avx_srai_epi32(AVXOp):
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_srai_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        op_class = 'SimdShiftOp'
        code = '''
            int sizeBits = srcSize * 8;
            uint64_t shiftAmt = op2_uqw;
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint32_t arg1Bits = VecSrcReg1_udw[i];
                uint32_t resBits;
                if( shiftAmt >= sizeBits )
                    resBits = (bits(arg1Bits, sizeBits-1)) ? mask(sizeBits) : 0;
                else {
                    resBits = arg1Bits >> shiftAmt;
                    resBits |= (0 - (resBits & (ULL(1) << (sizeBits-1-shiftAmt))));
                }
                VecDestReg_udw[i] = resBits;
            }
        '''

    class gem5_avx_srl_epu32(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_udw = { 0 };
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            if( shiftAmt < 32 ) {
                int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
                for(int i=0; i<count; i++)
                    VecDestReg_udw[i] = VecSrcReg1_udw[i] >> shiftAmt;
            }
        '''

    class gem5_avx_srl_epu32_imm(AVXOp):
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_srl_epu32_imm, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_udw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            if( shiftAmt < 32 ) {
                int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
                for(int i=0; i<count; i++)
                    VecDestReg_udw[i] = VecSrcReg1_udw[i] >> shiftAmt;
            }
        '''

    class gem5_avx_srl_epu64(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            if( shiftAmt < 64 ) {
                int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
                for(int i=0; i<count; i++)
                    VecDestReg_uqw[i] = VecSrcReg1_uqw[i] >> shiftAmt;
            }
        '''

    class gem5_avx_srl_epu64_imm(AVXOp):
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_srl_epu64_imm, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            if( shiftAmt < 64 ) {
                int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
                for(int i=0; i<count; i++)
                    VecDestReg_uqw[i] = VecSrcReg1_uqw[i] >> shiftAmt;
            }
        '''

    class gem5_avx_bsrli_epu128(AVXOp):
        op_class = 'SimdShiftOp'
        def __init__(self, dest, src1, op2, size, ext):
            super(gem5_avx_bsrli_epu128, self).__init__(dest, \
                src1, "InstRegIndex(0)", op2, size, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            if( (shiftAmt < 16) && (shiftAmt >= 8) ) {
                for(int i=0; i<cnt; i+=2)
                    VecDestReg_uqw[i] =
                            VecSrcReg1_uqw[i+1] >> ((shiftAmt-8)*8);
            }
            else {
                for(int i=0; i<cnt; i+=2) {
                    VecDestReg_uqw[i  ] =
                            VecSrcReg1_uqw[i+1] << ((8-shiftAmt)*8) |
                            VecSrcReg1_uqw[i  ] >> (shiftAmt*8);
                    VecDestReg_uqw[i+1] =
                            VecSrcReg1_uqw[i+1] >> (shiftAmt*8);
                }
            }
        '''

#    class _mm256_sll_epi16(AVXOp):
#        op_class = 'SimdShiftOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                uw16_dest_uw16[i] = uw16_src1_uw16[i] << uqw2_src2_uqw2[0];
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''
#
#    class _mm256_sll_epi16_imm(AVXOp):
#        def __init__(self, dest, src, op2, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm256_sll_epi16_imm, self).__init__(dest, src, \
#                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
#        op_class = 'SimdShiftOp'
#        code = '''
#            for(int i=0; i<ext; i++)
#                uw16_dest_uw16[i] = uw16_src1_uw16[i] << op2_uqw;
#            for(int i=ext; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#        '''

    class gem5_avx_sll_epu32(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_udw = { 0 };
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            if( shiftAmt < 32 ) {
                int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
                for(int i=0; i<count; i++)
                    VecDestReg_udw[i] = VecSrcReg1_udw[i] << shiftAmt;
            }
        '''

    class gem5_avx_sll_epu32_imm(AVXOp):
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_sll_epu32_imm, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_udw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            if( shiftAmt < 32 ) {
                int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
                for(int i=0; i<count; i++)
                    VecDestReg_udw[i] = VecSrcReg1_udw[i] << shiftAmt;
            }
        '''

    class gem5_avx_sll_epu64(AVXOp):
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = VecSrcReg2_uqw[0];
            if( shiftAmt < 64 ) {
                int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
                for(int i=0; i<count; i++)
                    VecDestReg_uqw[i] = VecSrcReg1_uqw[i] << shiftAmt;
            }
        '''

    class gem5_avx_sll_epu64_imm(AVXOp):
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_sll_epu64_imm, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        op_class = 'SimdShiftOp'
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            if( shiftAmt < 64 ) {
                int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
                for(int i=0; i<count; i++)
                    VecDestReg_uqw[i] = VecSrcReg1_uqw[i] << shiftAmt;
            }
        '''

    class gem5_avx_slli_epu128(AVXOp):
        op_class = 'SimdShiftOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_slli_epu128, self).__init__(dest, src, \
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            uint64_t shiftAmt = op2_uqw;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i+=2) {
                if( shiftAmt >= 8 ) {
                    VecDestReg_uqw[i  ] = 0;
                    VecDestReg_uqw[i+1] =
                            VecSrcReg1_uqw[i] << ((shiftAmt-8)*8);
                }
                else {
                    VecDestReg_uqw[i  ] = 
                            VecSrcReg1_uqw[i  ] << (shiftAmt*8);
                    VecDestReg_uqw[i+1] = 
                            VecSrcReg1_uqw[i+1] << (shiftAmt*8) |
                            VecSrcReg1_uqw[i  ] >> ((8-shiftAmt)*8);
                }
            }
        '''

#    class _mm256_sll_epi256(AVXOp):
#        def __init__(self, dest, src, op2, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm256_sll_epi256, self).__init__(dest, src, \
#                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
#        op_class = 'SimdShiftOp'
#        code = '''
#            uint64_t shiftAmt = op2_uqw;
#            int cnt = ext * 2;
#            if( shiftAmt >= 16)
#                uqw4_dest_uqw4 = (ulong4) {0};
#            else if( shiftAmt >= 8 ) {
#                for(int i=0; i<cnt; i+=2)
#                    uqw4_dest_uqw4[i+1] = uqw4_src1_uqw4[0] << ((shiftAmt-8)*8);
#                for(int i=cnt; i<4; i++)
#                    uqw4_dest_uqw4[i] = 0;
#            }
#            else {
#                for(int i=0; i<cnt; i+=2) {
#                    uqw4_dest_uqw4[i  ] = uqw4_src1_uqw4[i] << (shiftAmt*8);
#                    uqw4_dest_uqw4[i+1] = uqw4_src1_uqw4[i+1] << (shiftAmt*8) |
#                                        uqw4_src1_uqw4[i] >> ((8-shiftAmt)*8);
#                }
#                for(int i=cnt; i<4; i++)
#                    uqw4_dest_uqw4[i] = 0;
#            }
#        '''

    class gem5_avx_shuffle_epi8(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_ub = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++) {
                uint8_t arg2 = VecSrcReg2_ub[i];
                uint8_t index = (arg2 & mask(4)) | (i & 0x30);
                VecDestReg_ub[i] = ( bits(arg2, 7) ) ?
                                    0 : VecSrcReg1_ub[index];
            }
        '''

    class gem5_avx_shufflelo_epu16(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_shufflelo_epu16, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i+=8) {
                for(int j=0; j<4; j++) {
                    int idx = (op2_uqw >> (j*2)) & mask(2);
                    VecDestReg_uw[i+j] = VecSrcReg1_uw[i+idx];
                }
                for(int j=4; j<8; j++)
                    VecDestReg_uw[i+j] = VecSrcReg1_uw[i+j];
            }
        '''

    class gem5_avx_shufflehi_epu16(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_shufflehi_epu16, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i+=8) {
                for(int j=0; j<4; j++)
                    VecDestReg_uw[i+j] = VecSrcReg1_uw[i+j];
                for(int j=4; j<8; j++) {
                    int idx = (op2_uqw >> ((j-4)*2)) & mask(2);
                    VecDestReg_uw[i+j] = VecSrcReg1_uw[i+4+idx];
                }
            }
        '''

    class gem5_avx_shuffle_epu32(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_shuffle_epu32, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            uint64_t shiftAmt = 0;
            for(int i=0; i<count/4; i++)
                shiftAmt |= ((op2_uqw & mask(8)) << (i*8));

            VecDestReg_udw = { 0 };
            for(int i=0; i<count; i++) {
                int idx = (shiftAmt & mask(2)) | ( i & 0xC);
                VecDestReg_udw[i] = VecSrcReg1_udw[idx];
                shiftAmt = shiftAmt >> 2;
            }
        '''

    class gem5_avx_shuffle_ps(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i+=4) {
                    VecDestReg_udw[i  ] =
                            VecSrcReg1_udw[i+((ext     ) & mask(2))];
                    VecDestReg_udw[i+1] =
                            VecSrcReg1_udw[i+((ext >> 2) & mask(2))];
                    VecDestReg_udw[i+2] =
                            VecSrcReg2_udw[i+((ext >> 4) & mask(2))];
                    VecDestReg_udw[i+3] =
                            VecSrcReg2_udw[i+((ext >> 6) & mask(2))];
            }
        '''

    class gem5_avx_shuffle_pd(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i+=2) {
                VecDestReg_uqw[i  ] = 
                        VecSrcReg1_uqw[i+((ext >> (i  )) & mask(1))];
                VecDestReg_uqw[i+1] = 
                        VecSrcReg2_uqw[i+((ext >> (i+1)) & mask(1))];
            }
        '''

    class gem5_evex_shuffle_32x4(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_udw = { 0 };
            uint8_t shiftAmt = ext & mask(8);
            int count = zmmOp() ? 4 : 2;
            int maskBits = count / 2;

            for(int i=0; i<count/2; i++) {
                int idx = (shiftAmt & mask(maskBits)) * 4;
                for(int j=0; j<4; j++)
                    VecDestReg_udw[i*4+j] = VecSrcReg1_udw[idx+j];
                shiftAmt = shiftAmt >> maskBits;
            }
            for(int i=count/2; i<count; i++) {
                int idx = (shiftAmt & mask(maskBits)) * 4;
                for(int j=0; j<4; j++)
                    VecDestReg_udw[i*4+j] = VecSrcReg2_udw[idx+j];
                shiftAmt = shiftAmt >> maskBits;
            }
        '''

    class gem5_evex_shuffle_64x2(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_uqw = { 0 };
            uint8_t shiftAmt = ext & mask(8);
            int count    = zmmOp() ? 4 : 2;
            int maskBits = count / 2;

            for(int i=0; i<count/2; i++) {
                int idx = (shiftAmt & mask(maskBits)) * 2;
                VecDestReg_uqw[i*2  ] = VecSrcReg1_uqw[idx  ];
                VecDestReg_uqw[i*2+1] = VecSrcReg1_uqw[idx+1];
                shiftAmt = shiftAmt >> maskBits;
            }
            for(int i=count/2; i<count; i++) {
                int idx = (shiftAmt & mask(maskBits)) * 2;
                VecDestReg_uqw[i*2  ] = VecSrcReg2_uqw[idx  ];
                VecDestReg_uqw[i*2+1] = VecSrcReg2_uqw[idx+1];
                shiftAmt = shiftAmt >> maskBits;
            }
        '''

#    class _mm256_unpacklo_epi8(AVXOp):
#        op_class = 'SimdShuffleOp'
#        code = '''
#            int cnt = 8 / destSize;
#            for(int i=0; i<cnt; i++) {
#                ub32_dest_ub32[i*2  ] = ub32_src1_ub32[i];
#                ub32_dest_ub32[i*2+1] = ub32_src2_ub32[i];
#            }
#            for(int i=cnt; i<cnt*2; i++) {
#                ub32_dest_ub32[i*2  ] = ( ext ) ? (ub32_src1_ub32[i+cnt]) : 0;
#                ub32_dest_ub32[i*2+1] = ( ext ) ? (ub32_src2_ub32[i+cnt]) : 0;
#            }
#        '''
#
#    class _mm256_unpacklo_epi16(AVXOp):
#        op_class = 'SimdShuffleOp'
#        code = '''
#            int cnt = 8 / destSize;
#            for(int i=0; i<cnt; i++) {
#                uw16_dest_uw16[i*2  ] = uw16_src1_uw16[i];
#                uw16_dest_uw16[i*2+1] = uw16_src2_uw16[i];
#            }
#            for(int i=cnt; i<cnt*2; i++) {
#                uw16_dest_uw16[i*2  ] = ( ext ) ? (uw16_src1_uw16[i+cnt]) : 0;
#                uw16_dest_uw16[i*2+1] = ( ext ) ? (uw16_src2_uw16[i+cnt]) : 0;
#            }
#        '''

    class gem5_avx_unpacklo_epu32(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i+=4) {
                VecDestReg_udw[i  ] = VecSrcReg1_udw[i  ];
                VecDestReg_udw[i+1] = VecSrcReg2_udw[i  ];
                VecDestReg_udw[i+2] = VecSrcReg1_udw[i+1];
                VecDestReg_udw[i+3] = VecSrcReg2_udw[i+1];
            }
        '''

    class gem5_avx_unpacklo_epu64(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i+=2) {
                VecDestReg_uqw[i  ] = VecSrcReg1_uqw[i];
                VecDestReg_uqw[i+1] = VecSrcReg2_uqw[i];
            }
        '''

#    class _mm256_unpackhi_epi8(AVXOp):
#        op_class = 'SimdShuffleOp'
#        code = '''
#            int cnt = 8 / destSize;
#            for(int i=0; i<cnt; i++) {
#                ub32_dest_ub32[i*2  ] = ub32_src1_ub32[i+cnt];
#                ub32_dest_ub32[i*2+1] = ub32_src2_ub32[i+cnt];
#            }
#            for(int i=cnt; i<cnt*2; i++) {
#                ub32_dest_ub32[i*2  ] = ( ext ) ? ub32_src1_ub32[i+cnt*2] : 0;
#                ub32_dest_ub32[i*2+1] = ( ext ) ? ub32_src2_ub32[i+cnt*2] : 0;
#            }
#        '''
#
#    class _mm256_unpackhi_epi16(AVXOp):
#        op_class = 'SimdShuffleOp'
#        code = '''
#            int cnt = 8 / destSize;
#            for(int i=0; i<cnt; i++) {
#                uw16_dest_uw16[i*2  ] = uw16_src1_uw16[i+cnt];
#                uw16_dest_uw16[i*2+1] = uw16_src2_uw16[i+cnt];
#            }
#            for(int i=cnt; i<cnt*2; i++) {
#                uw16_dest_uw16[i*2  ] = ( ext ) ?
#                        uw16_src1_uw16[i+cnt*2] : 0;
#                uw16_dest_uw16[i*2+1] = ( ext ) ?
#                        uw16_src2_uw16[i+cnt*2] : 0;
#            }
#        '''

    class gem5_avx_unpackhi_epu32(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i+=4) {
                VecDestReg_udw[i  ] = VecSrcReg1_udw[i+2];
                VecDestReg_udw[i+1] = VecSrcReg2_udw[i+2];
                VecDestReg_udw[i+2] = VecSrcReg1_udw[i+3];
                VecDestReg_udw[i+3] = VecSrcReg2_udw[i+3];
            }
        '''

    class gem5_avx_unpackhi_epu64(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i+=2) {
                VecDestReg_uqw[i  ] = VecSrcReg1_uqw[i+1];
                VecDestReg_uqw[i+1] = VecSrcReg2_uqw[i+1];
            }
        '''

    class gem5_avx_blend_epi16(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_uw = { 0 };
            int cnt = 8;
            for(int i=0; i<cnt; i++)
                VecDestReg_uw[i] = ( (ext >> i) & mask(1) ) ?
                            (VecSrcReg2_uw[i]) : (VecSrcReg1_uw[i]);
            if( ymmOp() ) {
                for(int i=0; i<cnt; i++)
                    VecDestReg_uw[cnt+i] = ( (ext >> i) & mask(1) ) ?
                            (VecSrcReg2_uw[cnt+i]) : (VecSrcReg1_uw[cnt+i]);
            }
        '''

    class gem5_avx_blend_ps(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_udw = { 0 };
            int cnt = ymmOp() ? 8 : 4;
            for(int i=0; i<cnt; i++)
                VecDestReg_udw[i] = ( bits(ext, i) ) ?
                            (VecSrcReg2_udw[i]) : (VecSrcReg1_udw[i]);
        '''

    class gem5_avx_blend_pd(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int cnt = ymmOp() ? 4 : 2;
            for(int i=0; i<cnt; i++)
                VecDestReg_uqw[i] = ( (ext >> i) & mask(1) ) ?
                            (VecSrcReg2_uqw[i]) : (VecSrcReg1_uqw[i]);
        '''

#    class _mm_blendv_ps(AVXOp):
#        def __init__(self, dest, src1, src2, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm_blendv_ps, self).__init__(dest, src1, src2, \
#                    "InstRegIndex(VECTORREG_XMM0)", size, destSize, srcSize, ext)
#        op_class = 'SimdMiscOp'
#        code = '''
#            for(int i=0; i<4; i++)
#                udw4_dest_udw4[i] = ( (udw4_src3_udw4[i] >> 31) & 0x1 )
#                    ? (udw4_src2_udw4[i]) : (udw4_src1_udw4[i]);
#        '''
#
#    class _mm_blendv_pd(AVXOp):
#        def __init__(self, dest, src1, src2, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm_blendv_pd, self).__init__(dest, src1, src2, \
#                    "InstRegIndex(VECTORREG_XMM0)", size, destSize, srcSize, ext)
#        op_class = 'SimdMiscOp'
#        code = '''
#            for(int i=0; i<2; i++)
#                uqw2_dest_uqw2[i] = ( (uqw2_src3_uqw2[i] >> 63) & 0x1 )
#                    ? (uqw2_src2_uqw2[i]) : (uqw2_src1_uqw2[i]);
#        '''

    class gem5_avx_blendv_ps(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = ymmOp() ? 8 : 4;
            int shiftAmt = srcSize * 8 - 1;
            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = ( (VecSrcReg3_udw[i] >> shiftAmt) & 0x1 ) ?
                                (VecSrcReg2_udw[i]) : (VecSrcReg1_udw[i]);
        '''

    class gem5_avx_blendv_pd(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = ymmOp() ? 4 : 2;
            int shiftAmt = srcSize * 8 - 1;
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = ( (VecSrcReg3_uqw[i] >> shiftAmt) & 0x1 ) ?
                                (VecSrcReg2_uqw[i]) : (VecSrcReg1_uqw[i]);
        '''

    class gem5_avx_blend_vb(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_ub = { 0 };
            int count = ymmOp() ? 32 : 16;
            for(int i=0; i<count; i++)
                VecDestReg_ub[i] = ( VecSrcReg3_ub[i] & 0x80 ) ?
                        (VecSrcReg2_ub[i]) : (VecSrcReg1_ub[i]);
        '''

    class gem5_avx_palignr_epi8(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_ub = { 0 };
            const int nb = 16;
            uint8_t result[32];
            uint shiftAmt = (ext & mask(8));
            int count = zmmOp() ? 4 : (ymmOp() ? 2 : 1);
            for(int i=0; i<count; i++) {
                for(int j=0; j<nb; j++) {
                    result[j   ] = VecSrcReg2_ub[i*nb+j];
                    result[j+nb] = VecSrcReg1_ub[i*nb+j];
                }
                for(int j=0; j<nb; j++)
                    VecDestReg_ub[i*nb+j] = result[shiftAmt+j];
            }
        '''

    class gem5_avx_movemask_epi8(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_movemask_epi8, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdMiscOp'
        code = '''
            int shiftBits = srcSize * 8 - 1;
            int count = ymmOp() ? 32 : 16;
            DestReg = 0;
            for(int i=0; i<count; i++)
                DestReg |= ((VecSrcReg1_ub[i] >> shiftBits) & mask(1)) << i;
        '''

    class gem5_avx_movemask_epi32(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_movemask_epi32, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdMiscOp'
        code = '''
            int shiftBits = srcSize * 8 - 1;
            int count = ymmOp() ? 8 : 4;
            DestReg = 0;
            for(int i=0; i<count; i++)
                DestReg |= ((VecSrcReg1_udw[i] >> shiftBits) & mask(1)) << i;
        '''

    class gem5_avx_movemask_epi64(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_movemask_epi64, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdMiscOp'
        code = '''
            int shiftBits = srcSize * 8 - 1;
            int count = ymmOp() ? 4 : 2;
            DestReg = 0;
            for(int i=0; i<count; i++)
                DestReg |= ((VecSrcReg1_uqw[i] >> shiftBits) & mask(1)) << i;
        '''

    class gem5_avx_maskmove_ps(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                uint8_t maskVal = (VecSrcReg1_udw[i] >> 31) & mask(1);
                if( maskVal != 0 )
                    VecDestReg_udw[i] = VecSrcReg2_udw[i];
                else if( (ext & mask(1)) == 1 )
                    VecDestReg_udw[i] = VecSrcReg3_udw[i];
            }
        '''

    class gem5_avx_maskmove_pd(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                if( bits(VecSrcReg1_uqw[i], 63) != 0 )
                    VecDestReg_uqw[i] = VecSrcReg2_uqw[i];
                else if( (ext & mask(1)) == 1 )
                    VecDestReg_uqw[i] = VecSrcReg3_uqw[i];
            }
        '''

    class gem5_avx_move_epu32(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_move_epu32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; ++i)
                VecDestReg_udw[i] = VecSrcReg1_udw[i];
        '''

    class gem5_avx_move_epu64(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_move_epu64, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : (xmmOp() ? 2 : 1));
            for(int i=0; i<count; ++i)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[i];
        '''

#    class gem5_mm256_mov_vec2vec(AVXOp):
#        op_class = 'SimdAluOp'
#        def __init__(self, dest, src, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(gem5_mm256_mov_vec2vec, self).__init__(dest, src, \
#                    "InstRegIndex(0)", "InstRegIndex(0)", \
#                    size, destSize, srcSize, ext)
#        code = '''
#            VecDestReg_uqw = { 0 };
#            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
#            for(int i=0; i<count; ++i)
#                VecDestReg_uqw[i] = VecSrcReg1_uqw[i];
#        '''

    class gem5_mm256_move_si128_epi32(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_move_si128_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = 'DestReg = VecSrcReg1_udw[0];'

    class gem5_mm256_move_si128_epi64(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_move_si128_epi64, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = 'DestReg = VecSrcReg1_uqw[0];'

    class gem5_mm256_move_epi32_si128(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_move_epi32_si128, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            VecDestReg_udw[0] = SrcReg1_uqw & mask(32);
        '''

    class gem5_mm256_move_epi64_si128(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_move_epi64_si128, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = SrcReg1_uqw;
        '''

#    class gem5_avx_move_epi64(FpUnaryOp):
#        op_class = 'SimdAluOp'
#        code = '''
#            Iu64x4Dest_uqw4 = { 0 };
#            Iu64x4Dest_uqw4[0] = Iu64x2Src1_uqw2[0];
#        '''
#        else_code = 'Iu64x4Dest_uqw4 = Iu64x4Dest_uqw4'
#        cond_check = "checkCondition(ccFlagBits | cfofBits | dfBit | \
#                                     ecfBit | ezfBit, src2)"

    class gem5_avx_movedup_pd(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_movedup_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i+=2) {
                VecDestReg_uqw[i  ] = VecSrcReg1_uqw[i];
                VecDestReg_uqw[i+1] = VecSrcReg1_uqw[i];
            }
        '''

    class gem5_avx_moveldup_ps(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_moveldup_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i+=2) {
                VecDestReg_udw[i  ] = VecSrcReg1_udw[i];
                VecDestReg_udw[i+1] = VecSrcReg1_udw[i];
            }
        '''

    class gem5_avx_movehdup_ps(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_movehdup_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i+=2) {
                VecDestReg_udw[i  ] = VecSrcReg1_udw[i+1];
                VecDestReg_udw[i+1] = VecSrcReg1_udw[i+1];
            }
        '''

    class gem5_avx_move_ss(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            VecDestReg_udw[0] = VecSrcReg2_udw[0];
            VecDestReg_udw[1] = VecSrcReg1_udw[1];
            VecDestReg_udw[2] = VecSrcReg1_udw[2];
            VecDestReg_udw[3] = VecSrcReg1_udw[3];
        '''

    class gem5_avx_move_sd(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = VecSrcReg2_uqw[0];
            VecDestReg_uqw[1] = VecSrcReg1_uqw[0];
        '''

    class gem5_avx_loadl_pi(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = VecSrcReg2_uqw[0];
            VecDestReg_uqw[1] = VecSrcReg1_uqw[1];
        '''

    class gem5_avx_loadh_pi(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = VecSrcReg1_uqw[0];
            VecDestReg_uqw[1] = VecSrcReg2_uqw[0];
        '''

    class gem5_avx_cvtsi32n64_ss(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            assert(srcSize == 4 || srcSize == 8);
            float farg = (srcSize == 8) ? ((float) SrcReg2) :
                         ((float) *((int32_t *) &SrcReg2));
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = farg;
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_cvtsi32n64_sd(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            assert(srcSize == 4 || srcSize == 8);
            double darg = ( srcSize == 8 ) ? (SrcReg2) :
                          ((double) *((int32_t *) &SrcReg2));
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = darg;
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_cvtsu32n64_ss(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            assert(srcSize == 4 || srcSize == 8);
            float farg = (srcSize == 8) ? ((float) SrcReg2) :
                         ((float) *((uint32_t *) &SrcReg2));
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = farg;
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_cvtsu32n64_sd(AVXOp):
        op_class = 'SimdMiscOp'
        code = '''
            assert(srcSize == 4 || srcSize == 8);
            double darg = ( srcSize == 8 ) ? (SrcReg2) :
                          ((double) *((uint32_t *) &SrcReg2));
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = darg;
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_cvtss_sd(AVXOp):
        op_class = 'FloatCvtOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (double) VecSrcReg2_sf[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_cvtsd_ss(AVXOp):
        op_class = 'FloatCvtOp'
        code = '''
            VecDestReg_sf = { 0};
            VecDestReg_sf[0] = (float) VecSrcReg2_df[0];
            VecDestReg_sf[1] = VecSrcReg1_sf[1];
            VecDestReg_sf[2] = VecSrcReg1_sf[2];
            VecDestReg_sf[3] = VecSrcReg1_sf[3];
        '''

    class gem5_avx_cvtps_pd(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtps_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdFloatCvtOp'
        code = '''
            VecDestReg_df = { 0 };
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<cnt; i++)
                VecDestReg_df[i] = (double) VecSrcReg1_sf[i];
        '''

    class gem5_avx_cvtpd_ps(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtpd_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdFloatCvtOp'
        code = '''
            VecDestReg_sf = { 0 };
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<cnt; i++)
                VecDestReg_sf[i] = (float) VecSrcReg1_df[i];
        '''

    class gem5_avx_cvtps_epi32(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtps_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_sdw = { 0 };
            int cnt = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<cnt; i++) {
                float arg = VecSrcReg1_sf[i];
                if( ext & 0x4 )
                    arg += (arg  >= 0) ? ( 0.5 ) : ( -0.5 );
                VecDestReg_sdw[i] = (int32_t) arg;
            }
        '''

    class gem5_avx_cvtpd_epi32(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtpd_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdMiscOp'
        code = '''
            VecDestReg_sdw = { 0 };
            int cnt = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<cnt; i++) {
                double arg = VecSrcReg1_df[i];
                if( ext & 0x4 )
                    arg += (arg  >= 0) ? ( 0.5 ) : ( -0.5 );
                VecDestReg_sdw[i] = (int32_t) arg;
            }
        '''

    class gem5_avx_cvtepi32_ps(AVXOp):
        op_class = 'SimdFloatCvtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepi32_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                     size, destSize, srcSize, ext)
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = (float) VecSrcReg1_sdw[i];
        '''

    class gem5_avx_cvtepi32_pd(AVXOp):
        op_class = 'SimdFloatCvtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepi32_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = (double) VecSrcReg1_sdw[i];
        '''

    class gem5_avx_cvtepu32_ps(AVXOp):
        op_class = 'SimdFloatCvtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepu32_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                     size, destSize, srcSize, ext)
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_sf[i] = (float) VecSrcReg1_udw[i];
        '''

    class gem5_avx_cvtepu32_pd(AVXOp):
        op_class = 'SimdFloatCvtOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepu32_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_df[i] = (double) VecSrcReg1_udw[i];
        '''

    class gem5_avx_cvtepi32_epi64(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepi32_epi64, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_sqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; ++i)
                VecDestReg_sqw[i] = (int64_t) VecSrcReg1_sdw[i];
        '''

    class gem5_avx_cvtepu32_epi64(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepu32_epi64, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; ++i)
                VecDestReg_uqw[i] = VecSrcReg1_udw[i];
        '''

    class gem5_avx_cvtepi64_epi32(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_cvtepi64_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; ++i)
                VecDestReg_udw[i] = VecSrcReg1_uqw[i] & mask(32);
        '''

#    class _mm256_insert_epi8(AVXOp):
#        op_class = 'SimdAluOp'
#        code = '''
#            for(int i=0; i<16; i++)
#                ub32_dest_ub32[i] = ub16_src1_ub16[i];
#            for(int i=16; i<32; i++)
#                ub32_dest_ub32[i] = 0;
#            ub32_dest_ub32[imm8] = SrcReg2;
#        '''
#
#    class _mm256_insert_epi16(AVXOp):
#        op_class = 'SimdAluOp'
#        code = '''
#            for(int i=0; i<8; i++)
#                uw16_dest_uw16[i] = uw8_src1_uw8[i];
#            for(int i=8; i<16; i++)
#                uw16_dest_uw16[i] = 0;
#            uw16_dest_uw16[imm8] = SrcReg2;
#        '''

    class gem5_avx_insert_epi32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            for(int i=0; i<4; i++)
                VecDestReg_udw[i] = VecSrcReg1_udw[i];
            VecDestReg_udw[imm8] = SrcReg2_udw;
        '''

    class gem5_avx_insert_epi64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            for(int i=0; i<2; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[i];
            VecDestReg_uqw[imm8] = SrcReg2_uqw;
        '''

    class gem5_avx_insert_ps(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            uint8_t count_s = (ext >> 6) & mask(2);
            uint8_t count_d = (ext >> 4) & mask(2);
            uint8_t zmask = ext & mask(4);

            VecDestReg_udw = { 0 };
            for(int i=0; i<4; i++) {
                if( ((zmask >> i) & mask(1)) )
                    VecDestReg_udw[i] = 0;
                else
                    VecDestReg_udw[i] = (i == count_d) ?
                        (VecSrcReg2_udw[count_s]) : (VecSrcReg1_udw[i]);
            }
        '''

    class gem5_avx_insert_epu128(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 4 : 2;
            int dest = imm8 & mask(count/2);
            for(int i=0; i<count; i++) {
                if( i == dest ) {
                    VecDestReg_uqw[i*2  ] = VecSrcReg2_uqw[0];
                    VecDestReg_uqw[i*2+1] = VecSrcReg2_uqw[1];
                }
                else {
                    VecDestReg_uqw[i*2  ] = VecSrcReg1_uqw[i*2  ];
                    VecDestReg_uqw[i*2+1] = VecSrcReg1_uqw[i*2+1];
                }
            }
        '''

    class gem5_evex_inserti64x4(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            if( ext & mask(1) ) {
                for(int i=0; i<4; i++)
                    VecDestReg_uqw[i  ] = VecSrcReg1_uqw[i];
                for(int i=0; i<4; i++)
                    VecDestReg_uqw[i+4] = VecSrcReg2_uqw[i];
            }
            else {
                for(int i=0; i<4; i++)
                    VecDestReg_uqw[i] = VecSrcReg2_uqw[i];
                for(int i=4; i<8; i++)
                    VecDestReg_uqw[i] = VecSrcReg1_uqw[i];
            }
        '''

    class gem5_mm256_extractf128_si256(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_extractf128_si256, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = VecSrcReg1_uqw[ext*2  ];
            VecDestReg_uqw[1] = VecSrcReg1_uqw[ext*2+1];
        '''

    class gem5_evex_extracti64x2(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_extracti64x2, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            VecDestReg_uqw[0] = VecSrcReg1_uqw[ext*2  ];
            VecDestReg_uqw[1] = VecSrcReg1_uqw[ext*2+1];
        '''

    class gem5_evex_extracti64x4(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_extracti64x4, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            for(int i=0; i<4; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[ext*4+i];
        '''

    class gem5_avx_broadcast_ss(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcast_ss, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = VecSrcReg1_udw[0];
        '''

    class gem5_avx_broadcast_sd(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcast_sd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[0];
        '''

    class gem5_avx_broadcast_ps(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcast_ps, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            uint8_t modulo = ext & mask(4);

            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = VecSrcReg1_udw[i % modulo];
        '''

    class gem5_avx_broadcast_pd(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcast_pd, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2 );
            uint8_t modulo = ext & mask(3);

            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = VecSrcReg1_uqw[i % modulo];
        '''

    class gem5_avx_broadcast(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcast, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            int maskBits = 8 * srcSize;
            uint64_t arg1 = VecSrcReg1_uqw[0] & mask(maskBits);

            uint64_t result = 0;
            int count = 8 / srcSize;
            for(int j=0; j<count; j++)
                result |= arg1 << (maskBits * j);

            VecDestReg_uqw = { 0 };
            count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = result;
        '''

    class gem5_avx_broadcastmb_epi64(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcastmb_epi64, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = (OpMaskSrcReg1 & mask(8));
        '''

    class gem5_avx_broadcastmw_epi32(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_broadcastmw_epi32, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++)
                VecDestReg_udw[i] = (OpMaskSrcReg1 & mask(16));
        '''

    class gem5_avx_set1(AVXOp):
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_set1, self).__init__(dest, src, \
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            int maskBits = 8 * srcSize;
            uint64_t arg1 = SrcReg1_uqw & mask(maskBits);

            uint64_t result = 0;
            int count = 8 / srcSize;
            for(int j=0; j<count; j++)
                result |= arg1 << (maskBits * j);

            VecDestReg_uqw = { 0 };
            count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++)
                VecDestReg_uqw[i] = result;
        '''

    class gem5_mm256_testc(AVXOp):
        def __init__(self, src1, src2,\
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_mm256_testc, self).__init__("InstRegIndex(0)", src1, src2,\
                    "InstRegIndex(0)", size, destSize, srcSize, ext)
        op_class = 'SimdAluOp'
        code = '''
            int count = ymmOp() ? 4 : 2;
            uint64_t result1 = 0, result2 = 0;
            for(int i=0; i<count; i++) {
                result1 |= ( VecSrcReg1_uqw[i] & VecSrcReg2_uqw[i]);
                result2 |= (~VecSrcReg1_uqw[i] & VecSrcReg2_uqw[i]);
            }

            ccFlagBits = ccFlagBits & ~(SFBit | AFBit | PFBit);
            cfofBits   = cfofBits   & ~(OFBit);

            ccFlagBits = ( result1 == 0 ) ? (ccFlagBits | ZFBit) : (ccFlagBits & ~ZFBit);
            cfofBits   = ( result2 == 0 ) ? (cfofBits   | CFBit) : (cfofBits   & ~CFBit);
        '''

    class gem5_avx_kortest(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, src1, src2,\
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_kortest, self).__init__("InstRegIndex(0)", src1, src2,\
                    "InstRegIndex(0)", size, destSize, srcSize, ext)
        code = '''
            uint64_t maskBits = mask(srcSize*8);
            uint64_t res = (OpMaskSrcReg1 | OpMaskSrcReg2) & mask(maskBits);

            ccFlagBits = ccFlagBits & ~(SFBit | AFBit | PFBit);
            cfofBits   = cfofBits   & ~(OFBit);

            ccFlagBits = ( res == 0 ) ?
                         (ccFlagBits | ZFBit) : (ccFlagBits & ~ZFBit);
            cfofBits   = ( res == maskBits ) ?
                         (cfofBits   | CFBit) : (cfofBits   & ~CFBit);
        '''

#    class _mm256_permute_ps(AVXOp):
#        op_class = 'SimdAluOp'
#        def __init__(self, dest, src, \
#                size = None, destSize = None, srcSize = None, ext = None):
#            super(_mm256_permute_ps, self).__init__(dest, src,\
#                    "InstRegIndex(0)", "InstRegIndex(0)", size, destSize, srcSize, ext)
#        code = '''
#            for(int i=0; i<4; i++)
#                udw8_dest_udw8[i] = udw8_src1_udw8[(ext >> (i*2)) & 0x3];
#            for(int i=4; i<8; i++)                
#                udw8_dest_udw8[i] = ( ymmOp() ) ?
#                    (udw8_src1_udw8[(ext >> ((i & 0x3)*2)) & 0x3]) : (0);
#        '''
#
#    class _mm256_permutevar_ps(AVXOp):
#        op_class = 'SimdAluOp'
#        code = '''
#            int idx[8];
#            for(int i=0; i<ext; i++)
#                idx[i] = udw8_src2_udw8[i] & 0x3;
#            for(int i=4; i<ext; i++)
#                idx[i] = (udw8_src2_udw8[i] & 0x3) | 0x4;
#            for(int i=0; i<ext; i++)
#                udw8_dest_udw8[i] = udw8_src1_udw8[idx[i]];
#            for(int i=ext; i<8; i++)
#                udw8_dest_udw8[i] = 0;
#        '''

    class gem5_mm256_permutexvar_epi16(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uw = { 0 };
            int count = ymmOp() ? 16 : 8;
            int maskBits = ymmOp() ? 4 : 3;
            for(int i=0; i<count; i++) {
                uint16_t arg1 = VecSrcReg1_uw[i] & mask(maskBits);
                VecDestReg_uw[i] = VecSrcReg2_uw[arg1];
            }
        '''

    class gem5_avx_permutexvar_epi32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : 8;
            int maskBits = zmmOp() ? 4 : 3;
            for(int i=0; i<count; i++) {
                uint8_t arg1 = VecSrcReg1_udw[i] & mask(maskBits);
                VecDestReg_udw[i] = VecSrcReg2_udw[arg1];
            }
        '''

    class gem5_avx_permutexvar_epi64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : 4;
            int maskBits = zmmOp() ? 3 : 2;
            for(int i=0; i<count; i++) {
                uint8_t arg1 = VecSrcReg1_uqw[i] & mask(maskBits);
                VecDestReg_uqw[i] = VecSrcReg2_uqw[arg1];
            }
        '''

    class gem5_avx_permutex_epi64(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_permutex_epi64, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            uint8_t shiftAmt = op2_uqw;
            for(int i=0; i<4; i++) {
                VecDestReg_uqw[i] = VecSrcReg1_uqw[shiftAmt & mask(2)];
                shiftAmt = shiftAmt >> 2;
            }
            if( zmmOp() ) {
                shiftAmt = op2_uqw;
                for(int i=4; i<8; i++) {
                    VecDestReg_uqw[i] =
                            VecSrcReg1_uqw[4+(shiftAmt & mask(2))];
                    shiftAmt = shiftAmt >> 2;
                }
            }
        '''

    class gem5_avx_permute_ps(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_permute_ps, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                int index = (ext >> (i & mask(2))) & mask(2);
                VecDestReg_udw[i] = VecSrcReg1_udw[(i & 0xFC) + index];
            }
        '''

    class gem5_avx_permute_pd(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_permute_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                int index = (ext >> i) & mask(1);
                VecDestReg_uqw[i] = VecSrcReg1_uqw[(i & 0xFE) + index];
            }
        '''

    class gem5_avx_permutevar_pd(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                uint8_t maskBit = (VecSrcReg2_uqw[i] >> 1) & mask(1);
                uint8_t idx = i & 0xFE;
                VecDestReg_uqw[i] = maskBit ?
                        VecSrcReg1_uqw[idx+1] : VecSrcReg1_uqw[idx];
            }
        '''

    class gem5_avx_permute2f128_pd(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            if( (imm8 & 0x08) == 0 ) {
                switch(imm8 & mask(2)) {
                case 0:
                    VecDestReg_uqw[0] = VecSrcReg1_uqw[0];
                    VecDestReg_uqw[1] = VecSrcReg1_uqw[1];
                    break;
                case 1:
                    VecDestReg_uqw[0] = VecSrcReg1_uqw[2];
                    VecDestReg_uqw[1] = VecSrcReg1_uqw[3];
                    break;
                case 2:
                    VecDestReg_uqw[0] = VecSrcReg2_uqw[0];
                    VecDestReg_uqw[1] = VecSrcReg2_uqw[1];
                    break;
                case 3:
                    VecDestReg_uqw[0] = VecSrcReg2_uqw[2];
                    VecDestReg_uqw[1] = VecSrcReg2_uqw[3];
                    break;
                }
            }
            if( (imm8 & 0x80) == 0 ) {
                switch( (imm8 >> 4) & mask(2) ) {
                case 0:
                    VecDestReg_uqw[2] = VecSrcReg1_uqw[0];
                    VecDestReg_uqw[3] = VecSrcReg1_uqw[1];
                    break;
                case 1:
                    VecDestReg_uqw[2] = VecSrcReg1_uqw[2];
                    VecDestReg_uqw[3] = VecSrcReg1_uqw[3];
                    break;
                case 2:
                    VecDestReg_uqw[2] = VecSrcReg2_uqw[0];
                    VecDestReg_uqw[3] = VecSrcReg2_uqw[1];
                    break;
                case 3:
                    VecDestReg_uqw[2] = VecSrcReg2_uqw[2];
                    VecDestReg_uqw[3] = VecSrcReg2_uqw[3];
                    break;
                }
            }
        '''

# assume CS.L = 1 64 bit mode
    class Shlx(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            uint8_t maskBits = 32 << ext;
            uint64_t count = SrcReg2 & mask(( ext ) ? (6) : (5));
            DestReg = (SrcReg1 << count) & mask(maskBits);
        '''

# assume CS.L = 1 64 bit mode
    class Shrx(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            uint8_t maskBits = 32 << ext;
            uint64_t count = SrcReg2 & mask(( ext ) ? (6) : (5));
            DestReg = (SrcReg1 >> count) & mask(maskBits);
        '''

# assume CS.L = 1 64 bit mode
    class Sarx(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            uint8_t maskBits = 32 << ext;
            uint64_t count = SrcReg2 & mask(( ext ) ? (6) : (5));
            int sign = (SrcReg1 >> (maskBits-1)) & mask(1); 
            if( sign )
                DestReg = (0 - (SrcReg1 >> count)) & mask(maskBits);
            else
                DestReg = (SrcReg1 >> count) & mask(maskBits);
        '''

#    class Andn(AVXOp):
#        op_class = 'IntAluOp'
#        code = '''
#            DestReg = merge(DestReg, ~(SrcReg1) & SrcReg2, destSize);
#            cfofBits = cfofBits & ~(OFBit | CFBit);
#            ccFlagBits = ( DestReg == 0 ) ?
#                         (ccFlagBits | ZFBit) : (ccFlagBits & ~(ZFBit));
#            ccFlagBits = ( bits(DestReg,destSize*8-1) ) ?
#                         (ccFlagBits | SFBit) : (ccFlagBits & ~(SFBit));
#        '''

    class gem5_avx_fmadd132_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg1_sf[0] *
                               (double) VecSrcReg3_sf[0] +
                               (double) VecSrcReg2_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmadd132_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg1_sf[i] *
                                   (double) VecSrcReg3_sf[i] +
                                   (double) VecSrcReg2_sf[i];
            }
        '''

    class gem5_avx_fmadd213_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg1_sf[0] +
                               (double) VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmadd213_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg1_sf[i] +
                                   (double) VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fmadd231_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg3_sf[0] +
                               (double) VecSrcReg1_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmadd231_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg3_sf[i] +
                                   (double) VecSrcReg1_sf[i];
            }
        '''

    class gem5_avx_fmadd132_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg1_df[0] *
                               (__float128) VecSrcReg3_df[0] +
                               (__float128) VecSrcReg2_df[0];
            VecDestReg_df[1] = (__float128) VecSrcReg1_df[1];
        '''

    class gem5_avx_fmadd132_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg1_df[i] *
                                   (__float128) VecSrcReg3_df[i] +
                                   (__float128) VecSrcReg2_df[i];
            }
        '''

    class gem5_avx_fmadd213_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg1_df[0] +
                               (__float128) VecSrcReg3_df[0];
            VecDestReg_df[1] = (__float128) VecSrcReg1_df[1];
        '''

    class gem5_avx_fmadd213_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg1_df[i] +
                                   (__float128) VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fmadd231_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg3_df[0] +
                               (__float128) VecSrcReg1_df[0];
            VecDestReg_df[1] = (__float128) VecSrcReg1_df[1];
        '''

    class gem5_avx_fmadd231_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg3_df[i] +
                                   (__float128) VecSrcReg1_df[i];
            }
        '''

    class gem5_avx_fnmadd132_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg2_sf[0] -
                               (double) VecSrcReg1_sf[0] *
                               (double) VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmadd132_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] -
                                   (double) VecSrcReg1_sf[i] *
                                   (double) VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fnmadd213_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg3_sf[0] -
                               (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg1_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmadd213_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg3_sf[i] -
                                   (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg1_sf[i];
            }
        '''

    class gem5_avx_fnmadd231_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg1_sf[0] -
                               (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmadd231_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg1_sf[i] -
                                   (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fnmadd132_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg2_df[0] -
                               (__float128) VecSrcReg1_df[0] *
                               (__float128) VecSrcReg3_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmadd132_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] -
                                   (__float128) VecSrcReg1_df[i] *
                                   (__float128) VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fnmadd213_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg3_df[0] -
                               (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg1_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmadd213_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg3_df[i] -
                                   (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg1_df[i];
            }
        '''

    class gem5_avx_fnmadd231_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg1_df[0] -
                               (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg3_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmadd231_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg1_df[i] -
                                   (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fmsub132_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg1_sf[0] *
                               (double) VecSrcReg3_sf[0] -
                               (double) VecSrcReg2_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmsub132_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg1_sf[i] *
                                   (double) VecSrcReg3_sf[i] -
                                   (double) VecSrcReg2_sf[i];
            }
        '''

    class gem5_avx_fmsub213_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg1_sf[0] -
                               (double) VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmsub213_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg1_sf[i] -
                                   (double) VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fmsub231_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) VecSrcReg2_sf[0] *
                               (double) VecSrcReg3_sf[0] -
                               (double) VecSrcReg1_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fmsub231_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg3_sf[i] -
                                   (double) VecSrcReg1_sf[i];
            }
        '''

    class gem5_avx_fmsub132_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg1_df[0] *
                               (__float128) VecSrcReg3_df[0] -
                               (__float128) VecSrcReg2_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fmsub132_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg1_df[i] *
                                   (__float128) VecSrcReg3_df[i] -
                                   (__float128) VecSrcReg2_df[i];
            }
        '''

    class gem5_avx_fmsub213_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg1_df[0] -
                               (__float128) VecSrcReg3_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fmsub213_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg1_df[i] -
                                   (__float128) VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fmsub231_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) VecSrcReg2_df[0] *
                               (__float128) VecSrcReg3_df[0] -
                               (__float128) VecSrcReg1_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fmsub231_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg3_df[i] -
                                   (__float128) VecSrcReg1_df[i];
            }
        '''

    class gem5_avx_fnmsub132_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) -VecSrcReg2_sf[0] -
                               (double)  VecSrcReg1_sf[0] *
                               (double)  VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmsub132_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) -VecSrcReg2_sf[i] -
                                   (double)  VecSrcReg1_sf[i] *
                                   (double)  VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fnmsub213_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) -VecSrcReg3_sf[0] -
                               (double)  VecSrcReg2_sf[0] *
                               (double)  VecSrcReg1_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmsub213_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) -VecSrcReg3_sf[i] -
                                   (double)  VecSrcReg2_sf[i] *
                                   (double)  VecSrcReg1_sf[i];
            }
        '''

    class gem5_avx_fnmsub231_ss(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            VecDestReg_sf[0] = (double) -VecSrcReg1_sf[0] -
                               (double)  VecSrcReg2_sf[0] *
                               (double)  VecSrcReg3_sf[0];
            VecDestReg_sf[1] = (double) VecSrcReg1_sf[1];
            VecDestReg_sf[2] = (double) VecSrcReg1_sf[2];
            VecDestReg_sf[3] = (double) VecSrcReg1_sf[3];
        '''

    class gem5_avx_fnmsub231_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) -VecSrcReg1_sf[i] -
                                   (double)  VecSrcReg2_sf[i] *
                                   (double)  VecSrcReg3_sf[i];
            }
        '''

    class gem5_avx_fnmsub132_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) -VecSrcReg2_df[0] -
                               (__float128)  VecSrcReg1_df[0] *
                               (__float128)  VecSrcReg3_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmsub132_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) -VecSrcReg2_df[i] -
                                   (__float128)  VecSrcReg1_df[i] *
                                   (__float128)  VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fnmsub213_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) -VecSrcReg3_df[0] -
                               (__float128)  VecSrcReg2_df[0] *
                               (__float128)  VecSrcReg1_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmsub213_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) -VecSrcReg3_df[i] -
                                   (__float128)  VecSrcReg2_df[i] *
                                   (__float128)  VecSrcReg1_df[i];
            }
        '''

    class gem5_avx_fnmsub231_sd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            VecDestReg_df[0] = (__float128) -VecSrcReg1_df[0] -
                               (__float128)  VecSrcReg2_df[0] *
                               (__float128)  VecSrcReg3_df[0];
            VecDestReg_df[1] = VecSrcReg1_df[1];
        '''

    class gem5_avx_fnmsub231_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) -VecSrcReg1_df[i] -
                                   (__float128)  VecSrcReg2_df[i] *
                                   (__float128)  VecSrcReg3_df[i];
            }
        '''

    class gem5_avx_fmaddsub132_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg1_sf[i] *
                                   (double) VecSrcReg3_sf[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (double) -VecSrcReg2_sf[i] :
                                     (double)  VecSrcReg2_sf[i] );
            }
        '''

    class gem5_avx_fmaddsub213_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg1_sf[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (double) -VecSrcReg3_sf[i] :
                                     (double)  VecSrcReg3_sf[i] );
            }
        '''

    class gem5_avx_fmaddsub231_ps(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_sf = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                VecDestReg_sf[i] = (double) VecSrcReg2_sf[i] *
                                   (double) VecSrcReg3_sf[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (double) -VecSrcReg1_sf[i] :
                                     (double)  VecSrcReg1_sf[i] );
            }
        '''

    class gem5_avx_fmaddsub132_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg1_df[i] *
                                   (__float128) VecSrcReg3_df[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (__float128) -VecSrcReg2_df[i] :
                                     (__float128)  VecSrcReg2_df[i]);
            }
        '''

    class gem5_avx_fmaddsub213_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg1_df[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (__float128) -VecSrcReg3_df[i] :
                                     (__float128)  VecSrcReg3_df[i]);
            }
        '''

    class gem5_avx_fmaddsub231_pd(AVXOp):
        op_class = 'SimdFloatAddOp'
        code = '''
            VecDestReg_df = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                VecDestReg_df[i] = (__float128) VecSrcReg2_df[i] *
                                   (__float128) VecSrcReg3_df[i] +
                                   ( ((i%2) == (ext & mask(1))) ? 
                                     (__float128) -VecSrcReg1_df[i] :
                                     (__float128)  VecSrcReg1_df[i]);
            }
        '''

    class gem5_avx_conflict_epi32(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_conflict_epi32, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                for(int j=0; j<i; j++) {
                    if( VecSrcReg1_udw[i] == VecSrcReg1_udw[j] )
                        VecDestReg_udw[i] |= (1 << j);
                }
            }
        '''

    class gem5_avx_conflict_epi64(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_conflict_epi64, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                for(int j=0; j<i; j++) {
                    if( VecSrcReg1_uqw[i] == VecSrcReg1_uqw[j] )
                        VecDestReg_uqw[i] |= (1 << j);
                }
            }
        '''

    class gem5_moveto_opmask(AVXOp):
        op_class = 'IntAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_moveto_opmask, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = (ext) ?
                            (OpMaskSrcReg1 & mask(destSize*8)) :
                            (SrcReg1 & mask(destSize*8));
        '''

    class gem5_movefrom_opmask(AVXOp):
        op_class = 'IntAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_movefrom_opmask, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            DestReg = OpMaskSrcReg1 & mask(destSize * 8);
        '''

    class gem5_avx_kand(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            OpMaskDestReg = (OpMaskSrcReg1 & OpMaskSrcReg2) & mask(srcSize*8);
        '''

    class gem5_avx_kandn(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            OpMaskDestReg = (~OpMaskSrcReg1 & OpMaskSrcReg2) & mask(srcSize*8);
        '''

    class gem5_avx_knot(AVXOp):
        op_class = 'IntAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_knot, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = (~OpMaskSrcReg1) & mask(srcSize*8);
        '''

    class gem5_avx_kor(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            OpMaskDestReg = (OpMaskSrcReg1 | OpMaskSrcReg2) & mask(srcSize*8);
        '''

    class gem5_avx_kxor(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            OpMaskDestReg = (OpMaskSrcReg1 ^ OpMaskSrcReg2) & mask(srcSize*8);
        '''

    class gem5_avx_kxnor(AVXOp):
        op_class = 'IntAluOp'
        code = '''
            OpMaskDestReg = ~(OpMaskSrcReg1 ^ OpMaskSrcReg2) & mask(srcSize*8);
        '''

    class gem5_avx_kshiftr(AVXOp):
        op_class = 'IntAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_kshiftr, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            uint8_t maskBits = srcSize * 8;
            uint8_t shiftBits = ext & mask(8);
            if( shiftBits < (maskBits-1) )
                OpMaskDestReg = (OpMaskSrcReg1 & mask(maskBits)) >> shiftBits;
        '''

    class gem5_avx_kshiftl(AVXOp):
        op_class = 'IntAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_kshiftl, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            uint8_t maskBits = srcSize * 8;
            uint8_t shiftBits = ext & mask(8);
            if( shiftBits < maskBits )
                OpMaskDestReg = (OpMaskSrcReg1 & mask(maskBits)) << shiftBits;
        '''

    class gem5_evex_palign_epu32(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            uint8_t maskBits = zmmOp() ? 4 : (ymmOp() ? 3 : 2);
            uint8_t idx = ext & mask(maskBits);
            for(int i=0; i<count-idx; i++)
                VecDestReg_udw[i] = VecSrcReg2_udw[idx+i];
            for(int i=0; i<idx; i++)
                VecDestReg_udw[count-idx+i] = VecSrcReg1_udw[i];
        '''

    class gem5_evex_palign_epu64(AVXOp):
        op_class = 'SimdShuffleOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            uint8_t maskBits = zmmOp() ? 3 : (ymmOp() ? 2 : 1);
            uint8_t idx = ext & mask(maskBits);
            for(int i=0; i<count-idx; i++)
                VecDestReg_uqw[i] = VecSrcReg2_uqw[idx+i];
            for(int i=0; i<idx; i++)
                VecDestReg_uqw[count-idx+i] = VecSrcReg1_uqw[i];
        '''

    class gem5_evex_ternarylogic_epi32(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            uint8_t idx = ext & mask(8);
            for(int i=0; i<count; i++) {
                VecDestReg_udw[i] = vpternlog_table(idx, 32,
                                            VecSrcReg1_udw[i],
                                            VecSrcReg2_udw[i],
                                            VecSrcReg3_udw[i]);
            }
        '''

    class gem5_evex_ternarylogic_epi64(AVXOp):
        op_class = 'SimdAluOp'
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            uint8_t idx = ext & mask(8);
            for(int i=0; i<count; i++) {
                VecDestReg_uqw[i] = vpternlog_table(idx, 64,
                                            VecSrcReg1_uqw[i],
                                            VecSrcReg2_uqw[i],
                                            VecSrcReg3_uqw[i]);
            }
        '''

    class gem5_avx_fpclass_pd(AVXOp):
        op_class = 'SimdMiscOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_fpclass_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            uint8_t imm8s[8];
            for(int i=0; i<8; i++)
                imm8s[i] = (op2_ub >> i) & mask(1);

            uint32_t bResult;
            for(int i=0; i<count; i++) {
                uint64_t arg1 = VecSrcReg1_uqw[i];
                uint8_t NegNum = bits(arg1, 63);
                uint8_t ExpAllOnes = ( ((arg1 >> 52) & mask(11)) == 0x7FF ) ?
                                     ( 1 ) : ( 0 );
                uint8_t ExpAllZeros = ( ((arg1 >> 52) & mask(11)) == 0x0 ) ?
                                     ( 1 ) : ( 0 );
                uint8_t MantAllZeros = 0;  // MXCSR.DAZ = 0 (0x1f80 in process.cc)
                if( (arg1 & mask(52)) == 0 )  MantAllZeros = 1;

                uint8_t ZeroNumber = (ExpAllZeros & MantAllZeros);
                uint8_t SignalingBit = (arg1 >> 51) & mask(1);
                uint8_t sNaN_res = (ExpAllOnes & ~MantAllZeros) & ~SignalingBit; // sNaN
                uint8_t qNaN_res = (ExpAllOnes & ~MantAllZeros) & SignalingBit; // qNaN
                uint8_t Pzero_res = ~NegNum & ExpAllZeros & MantAllZeros; // +0
                uint8_t Nzero_res = NegNum & ExpAllZeros & MantAllZeros; // -0
                uint8_t PInf_res = ~NegNum & ExpAllOnes & MantAllZeros; // +Inf
                uint8_t NInf_res = NegNum & ExpAllOnes & MantAllZeros; // -Inf
                uint8_t Denorm_res = ExpAllZeros & ~MantAllZeros; // denorm
                uint8_t FinNeg_res = NegNum & ~ExpAllOnes & ~ZeroNumber; // -finite
                bResult = ( ( imm8s[0] & qNaN_res ) | (imm8s[1] & Pzero_res ) |
                          ( imm8s[2] & Nzero_res ) | ( imm8s[3] & PInf_res ) |
                          ( imm8s[4] & NInf_res ) | ( imm8s[5] & Denorm_res ) |
                          ( imm8s[6] & FinNeg_res ) | ( imm8s[7] & sNaN_res ) );
                OpMaskDestReg |= (bResult << i);
            }
        '''

    class gem5_evex_movm_epi8(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movm_epi8, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_ub = { 0 };
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++) {
                if( bits(OpMaskSrcReg1, i) )
                    VecDestReg_ub[i] = mask(8);
            }
        '''

    class gem5_evex_movm_epi16(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movm_epi16, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uw = { 0 };
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++) {
                if( bits(OpMaskSrcReg1, i) )
                    VecDestReg_uw[i] = mask(16);
            }
        '''

    class gem5_evex_movm_epi32(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movm_epi32, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_udw = { 0 };
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                if( bits(OpMaskSrcReg1, i) )
                    VecDestReg_udw[i] = mask(32);
            }
        '''

    class gem5_evex_movm_epi64(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movm_epi64, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                if( bits(OpMaskSrcReg1, i) )
                    VecDestReg_uqw[i] = mask(64);
            }
        '''

    class gem5_evex_movepi8(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movepi8, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 64 : (ymmOp() ? 32 : 16);
            for(int i=0; i<count; i++) {
                if( bits(VecSrcReg1_ub[i], 7) )
                    OpMaskDestReg |= (1 << i);
            }
        '''

    class gem5_evex_movepi16(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movepi16, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 32 : (ymmOp() ? 16 : 8);
            for(int i=0; i<count; i++) {
                if( bits(VecSrcReg1_uw[i], 16) )
                    OpMaskDestReg |= (1 << i);
            }
        '''

    class gem5_evex_movepi32(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movepi32, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 16 : (ymmOp() ? 8 : 4);
            for(int i=0; i<count; i++) {
                if( bits(VecSrcReg1_udw[i], 31) )
                    OpMaskDestReg |= (1 << i);
            }
        '''

    class gem5_evex_movepi64(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_evex_movepi64, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            OpMaskDestReg = 0;
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);
            for(int i=0; i<count; i++) {
                if( bits(VecSrcReg1_uqw[i], 63) )
                    OpMaskDestReg |= (1 << i);
            }
        '''

    class gem5_avx_getmant_pd(AVXOp):
        op_class = 'SimdShuffleOp'
        def __init__(self, dest, src, op2, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_getmant_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", op2, size, destSize, srcSize, ext)
        code = '''
            int count = zmmOp() ? 8 : (ymmOp() ? 4 : 2);

            int sign_control1 = bits(op2_uqw, 3);
            int sign_control0 = bits(op2_uqw, 2);
            uint8_t norm_interv = op2_uqw & mask(2);

            VecDestReg_uqw = { 0 };
            for(int i=0; i<count; i++) {
                VecDestReg_uqw[i] = getmat_fp64(VecSrcReg1_uqw[i], sign_control1, sign_control0, norm_interv); 
           }
        '''

    class gem5_avx_getexp_pd(AVXOp):
        op_class = 'SimdAluOp'
        def __init__(self, dest, src, \
                size = None, destSize = None, srcSize = None, ext = None):
            super(gem5_avx_getexp_pd, self).__init__(dest, src,\
                    "InstRegIndex(0)", "InstRegIndex(0)", \
                    size, destSize, srcSize, ext)
        code = '''
            VecDestReg_uqw = { 0 };
        '''
}};
